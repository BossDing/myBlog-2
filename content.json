{"meta":{"title":"认真搞定一切","subtitle":"会思考的天蝎座","description":"技术分享和生活体会","author":"cuteximi","url":"http://blog.cuteximi.com"},"pages":[{"title":"","date":"2018-06-25T13:49:50.500Z","updated":"2017-07-28T01:40:01.000Z","comments":true,"path":"google0b815720fb455fbe.html","permalink":"http://blog.cuteximi.com/google0b815720fb455fbe.html","excerpt":"","text":"google-site-verification: google0b815720fb455fbe.html"},{"title":"","date":"2018-06-25T13:49:50.499Z","updated":"2017-03-19T09:56:33.000Z","comments":true,"path":"404.html","permalink":"http://blog.cuteximi.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2018-10-23T11:08:36.562Z","updated":"2018-10-23T11:08:36.562Z","comments":false,"path":"about/index.html","permalink":"http://blog.cuteximi.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"categories","date":"2017-03-20T11:29:50.000Z","updated":"2017-06-30T14:39:17.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.cuteximi.com/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2018-06-25T13:49:50.501Z","updated":"2017-07-28T01:00:43.000Z","comments":true,"path":"links/index.html","permalink":"http://blog.cuteximi.com/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-25T13:49:50.502Z","updated":"2017-07-28T00:49:53.000Z","comments":true,"path":"tags/index.html","permalink":"http://blog.cuteximi.com/tags/index.html","excerpt":"","text":""},{"title":"timeline","date":"2018-06-25T13:49:50.502Z","updated":"2017-07-28T00:48:26.000Z","comments":true,"path":"timeline/index.html","permalink":"http://blog.cuteximi.com/timeline/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-10-23T11:04:20.960Z","updated":"2018-10-23T11:04:20.960Z","comments":false,"path":"repository/index.html","permalink":"http://blog.cuteximi.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"study-01","slug":"study-01","date":"2018-10-31T16:21:56.000Z","updated":"2018-11-01T05:24:17.170Z","comments":true,"path":"study-01/","link":"","permalink":"http://blog.cuteximi.com/study-01/","excerpt":"","text":"目录要注意的地方 时刻提醒自己！ 保持记笔记的习惯，按照统一(md)的格式可以每节课结束记一次，中午吃完饭总结上午学的东西，记录一次。下午学完总结下午所学的知识。晚上总结全天的学习记录。 周总结可以使用md、思维导图 不要让自己懒，想办法让自己保持专注，借助外力或者内在的暗示。 要有提前意识，预习，准备简历，准备笔试面试。 多与老师交流，先思考，再去问问题、 学习资料在网上找，或者找前辈要 白天听老师将一遍，晚上可以看别的机构的老师讲的内容，作为补充，此时视频可以为多倍速播放 回顾java的基础部分和Java web开发的知识点 多练习，多总结，要扎实基础。 记住节奏很快的，不要装懂。 今日学习目标 Linux系统的认识以及部署安装 认识Linux文件系统结构 实际操作文件和文件夹等 vi 编辑器的使用 文件传输 host 日间阶段总结MORNING6：00 - 8：00 Linux centos的官方问答：网址 镜像地址：地址 8：00 - 10：00 概述学习的内容，其实主要是 hadoop 和spark ,这两部分都要扎扎实实的学习。Linux 和 Nginx 都要熟练，这是基础。 NOON10：00 - 12：00 介绍Linux系统以及安装Linux系统。（pass） 安装版本为 centos 6.5 的 mini 版本。 AFTERNOON14：00 - 16：00 文件系统，对文件的操作。 涉及到创建，复制，删除，重命名。对于文件和文件件差不多。注意的是，对文件夹进行删除或者复制操作的时候，要使用参数 -r ( 或 -R )。 文件的创建有很多种方式，比如 touch, vi, echo 等都可以创建一个文件。使用 echo 的时候可以使用 &gt; 对文件的内容进行覆盖或者可以使用 &gt;&gt; 对文件的内容进行追加。删除文件的时候要注意参数的时候，使用 -f 参数可以强制删除文件。 命令有很多，记不住的时候，可以百度，google或者使用man 命令查看，最小化安装的 centos 是没有这个 man 命令的，可以使用 yum install man 来进程安装，加上参数 -y 可以自动同意一些 yes/no的安全性提示。 man cp 就会出现 cp 这个命令的说明手册。 16：00 - 17：00 一些 vi 的命令记录： vi filename 直接新建或者打开一个文件，鼠标停在第1行行首。 vi +4 filename 如上，只不过光标停在第四行行首。 vi + filename 如上，只不过光标停留在最后一行行首。 vi /tsl filename 打开文件，并将光标定位到 tsl 这个字符那里。 vi /正则表达式 filename 进入底部命令行模式： :set nu 或者 :set number ctrl + g 是显示光标所在的位置。 替换： :s/str1/str2/ 单行替换第一个匹配的字符 :s/str1/str2/g 全行替换 :%s/str1/str2/g 全文替换 复制粘贴删除： yy p P dd ndd :,$-1d 删除当前行到倒数第一行。 o 在下一行插入 O 在上一行插入。 I 行首 A 行末 图形化编辑器，能干的事情， vi 也能完成相应的功能。 vi编辑器，其实我很早就在是使用了这个编辑器了，因为用来这么长时间，也一直是那几个常用的命令。工具是用来生产的，这就足够了。一般模式，插入模式，底部命令行模式。 vim 是 vi 的高级版。 学习进度linux(5/12) 一天总结学习 linux 记住一句话，”一切皆文件”，什么都好办了。 很多人一说到Linux, 就会说自由。但是你真的而理解这种自由吗？这种自由是一种权力，能够决定你的计算机干什么，获取这种自由的唯一方式就是知道你的计算机在做什么。自由就是你的计算机没有任何秘密，你可以从计算机那里了解一切，只要你用心去寻找。 Linux 的作者 linus 是一个很牛逼的大神，昨天还看了2005年他在 Google 做讲座的视频，那时他在宣传 git （一个分布式的版本控制系统）,大神就是大神，整场都在 diss svn 以及 cvs 模式的版本控制工具，甚至还骂在坐的 Google 工程师蠢货…。因为他们问的问题要么太蠢，要么是质疑 git 为什么要采用分布式，习惯了使用集中式方式的他们简直被 linus 骂成了猪。黑客与画家，创造者等词联系在一起就不会那么难理解了吧。我们凡人是不懂得。。:-( 黑客崇尚自由，这与 Linux 系统特别匹配，对这个系统你得负责，你得知道你在干什么。 扯那么多…开始正题，记录一下 linux 的学习过程。 环境说明： Macbook Pro 10.14版本 VMware Fusion 10.1.3 centos 6.5 环境搭建1.安装 VMware Fusion略。 2.安装 centos 系统: 开头跳过检查（skip）。 3.配置网卡.. 编辑网卡： vi /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 TYPE=Ethernet BOOTPROTO=static ONBOOT=yes IPADDR=192.168.235.100 #设置 IP 地址 NETMASK=255.255.255.0 #设置子网掩码 ATEWAY=192.168.235.2 DNS1=114.114.114.114 重启网卡： service network restart 在这也可以配置DNS: vi /etc/resolv.conf nameserver 网关 4.关闭防火墙. iptables -F 5.配置 host 以及hostname host映射是在 /etc/hosts文件下进行配置： 初始是这样的，记录着本地回环地址与host的映射。 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 # 可以自己添加，比如 192.168.1.11 node1 192.168.1.12 node2 hostname是主机的标识，在 /etc/sysconfig/networking 中进行配置： NETWORKING=yes HOSTNAME=node01 认识 Linux文件系统1.目录结构 首先得清楚 linux 系统都有那些约定俗成的目录，各自的目录都一般放什么文件。 bin: 存放二进制可执行文件（ls,cat,mkdir等） sbin: 存放二进制文件，只有root用户才能访问 dev: 存放设备文件 usr: 存放系统应用程序，其中 /usr/local 是本地管理员软件安装目录 etc: 存放配置文件 lib: 存放一些共享类库和内核模块 tmp: 存放一些临时文件 var: 用于存放运行时需要改变数据的文件 boot: 存放开机所需的文件，开机时载入开机管理程序（bootloader），并映射到内存中。 home: 存放用户的东西 mnt:挂载目录 opt: 额外安装的可选软件的目录 文件的类型： 普通文件、目录文件、设备文件、链接文件、管道文件、套接字文件。 操作文件系统孰能省巧，多练几遍 vi 编辑器孰能省巧，多练几遍 host配置配置 host 以及hostname host映射是在 /etc/hosts文件下进行配置： 初始是这样的，记录着本地回环地址与host的映射。 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 + # 可以自己添加，比如 192.168.1.11 node1 192.168.1.12 node2 hostname是主机的标识，在 /etc/sysconfig/networking 中进行配置： NETWORKING=yes HOSTNAME=node01 遇到的问题以及解决方案问题1【问题描述】 mac 下如何保存ssh的连接信息,实现自动登录。 【问题思路】 在 windows 下有一款比较好用的 xshell 工具，但是 mac 下没有对应的替代品。但是有一款优秀的客户端 iTerm2。 【解决方案】 1.可以在【偏好设置】里面对应的【Profiles】页点击+号增加新的 profile 。 2.封装一个脚本，如下： #!/usr/bin/expect -f set timeout 60 # 设置超时时间 set username [lindex $argv 0] # 设置用户名 set password [lindex $argv 1] # 设置密码 set host [lindex $argv 2] # 设置ip或者域名 set port [lindex $argv 3] # 设置端口号 spawn ssh -p $port $username@$host # 启动一个的新的线程 # 模式 判断 expect { &quot;*yes/no&quot; { send &quot;yes\\r&quot;;exp_continue } &quot;*password:&quot; { send &quot;$password\\r&quot; } } expect &quot;$*&quot; { send &quot;pwd\\r&quot; } interact 其中，Expect是一个用来处理交互的命令。借助Expect，我们可以将交互过程写在一个脚本上，使之自动化完成。提供了 send , expect , spawn ，interact 等命令。 send：用于向进程发送字符串 expect：从进程接收字符串 spawn：启动新的进程 interact：允许用户交互 说明：spawn 是用来启动一个进程的，在它之后的expect 和 send 都是与该进程交互的。interact 起到干预的作用。 3.在1步骤中的新建的 profile 中新增命令行的内容： expect ~/.ssh/config_big_data/node01 root 123XX4 cq.xXX.teXh 4XX2 因为上述连接涉及安全信息，故部分字符串被 X 代替。 依次为：expect 脚本 username@password host port 4.总结，这种方式应该是比较有效的方式了，其实还可以把公钥传到服务器，采用秘钥的验证方式登录。 参考文章： 1.expect原理详解 2.expect脚本传参 问题2【问题描述】 克隆虚拟机之网卡配置 【问题思路】 网卡的 mac 地址冲突。修改一下 mac 地址即可。 【解决方案】 vi /etc/udev/rules.d/70-persistent-net.rules 注释掉eth0，然后将下面的eth1改名为eth0，复制下此eth0的mac地址 将此 mac 地址跳到 ifcfg-eth0 中即可。 重启服务器 reboot -h now 问题3【问题描述】 服务器之间如何实现免密登录，以及原理 【问题思路】 SSH以非对称加密实现身份验证，所以它是比较安全的。 身份验证有多种途径，例如①其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；②另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程私钥本身中不会传输到网络中。 【解决方案】 如何新建密钥对呢？ 1.查是否已存在密钥对，打开终端（Terminal）： 输入：ls -al ~/.ssh 查看是否输出密钥对,如果有的话，会输出如下文件信息：id_rsa 和 id_rsa.pub -rw——- 1 taoshilei staff 1679 Jun 25 22:34 id_rsa -rw-r–r– 1 taoshilei staff 403 Jun 25 22:34 id_rsa.pub 2、如果没有，则需要我们手动创建 输入：ssh-keygen -t rsa -b 4096 -C &quot;your_email&quot; ssh-keygen 是生成秘钥的工具之一。 SSH supports several public key algorithms（公开秘钥算法） for authentication keys. 1.rsa - A key size of at least 2048 bits is recommended for RSA; 4096 bits is better. 2.dsa - DSA in its original form is no longer recommended.(不推荐使用) 3.ecdsa - Only three key sizes are supported: 256, 384, and 521 (sic!) bits.(大多数ssh客户端支持) 4.ed25519 - Support for it in clients is not yet universal. (还没有普及) The algorithm is selected using the -t option and key size using the -b option. -t 参数指定加密算法，-b 参数指定加密的 用法如下：ssh-keygen -t rsa -b 4096 3.将公钥发送到服务器 使用 ssh-copy-id 工具。 用法：ssh-copy-id -i 公钥位置 user@host 之后会提示输入密码进行认证。 在这之后，公钥就会被添加到 服务器上的 ~/.ssh/authorized_keys 文件了里面。 一旦在服务器上配置了公钥，服务器会允许任何具有私钥的客户端进行连接用户登录，在登录的过程中，客户端会通过数字签名交换来证明拥有私钥。 免密登录图解 创建密钥并添加到服务器上。 登录认证流程 值得注意的是：服务端的 .ssh目录权限必须是700（rwx——），authorized_keys文件的权限是600(rw——-) 部分参考 https://www.ssh.com/ssh/keygen/#sec-What-Is-ssh-keygen","categories":[{"name":"大数据学习","slug":"大数据学习","permalink":"http://blog.cuteximi.com/categories/大数据学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.cuteximi.com/tags/Linux/"}]},{"title":"一站式解决服务器缺少编译环境的问题，别再为了缺少依赖而烦恼了！","slug":"一站式解决服务器缺少编译环境的问题，别再为了缺少依赖而烦恼了！","date":"2018-10-13T03:17:00.000Z","updated":"2018-10-13T03:17:39.026Z","comments":true,"path":"一站式解决服务器缺少编译环境的问题，别再为了缺少依赖而烦恼了！/","link":"","permalink":"http://blog.cuteximi.com/一站式解决服务器缺少编译环境的问题，别再为了缺少依赖而烦恼了！/","excerpt":"","text":"本文参考：https://github.com/pyenv/pyenv/wiki/Common-build-problems Ubuntu / Debian 系统： sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\ xz-utils tk-dev libffi-dev liblzma-dev Fedro / Centos /RHEL 系统： sudo yum install zlib-devel bzip2 bzip2-devel readline-devel sqlite sqlite-devel \\ openssl-devel xz xz-devel libffi-devel openSUSE : zypper in zlib-devel bzip2 libbz2-devel readline-devel sqlite3 sqlite3-devel libopenssl-devel xz xz-devel macOS: brew install readline xz 如果你的 macOS 是Mojave or higher (10.14+) sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target / NOTE: libssl-dev is required when compiling Python, installing libssl-dev will actually install zlib1g-dev, which leads to uninstall and re-install Python versions (installed before installing libssl-dev). On Redhat and derivatives the package is named openssl-devel.","categories":[{"name":"编译环境","slug":"编译环境","permalink":"http://blog.cuteximi.com/categories/编译环境/"}],"tags":[]},{"title":"解决这个警告⚠️：warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory","slug":"解决这个警告⚠️：warning-setlocale-LC-CTYPE-cannot-change-locale-UTF-8-No-such-file-or-directory","date":"2018-10-13T03:15:00.000Z","updated":"2018-10-13T04:01:50.856Z","comments":true,"path":"解决这个警告⚠️：warning-setlocale-LC-CTYPE-cannot-change-locale-UTF-8-No-such-file-or-directory/","link":"","permalink":"http://blog.cuteximi.com/解决这个警告⚠️：warning-setlocale-LC-CTYPE-cannot-change-locale-UTF-8-No-such-file-or-directory/","excerpt":"","text":"建议直接看方案2 在电脑上使用终端连接服务器的时候，经常会打印出如下警告： warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory 在网上查找相关解决方案：于是找到一篇文章:OS X Terminal: -bash: warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory Fix 解决方案1我使用的终端是 iTerm2, 找到它的配置（ iTerm2 &gt; Preference &gt; Advanced）：修改为如图: 出现上述警告本质上$LC_CTYPE 这个环境变量导致的。 查看我的物理机的 locale 配置： ximi:~$ locale LANG= LC_COLLATE=&quot;C&quot; LC_CTYPE=&quot;UTF-8&quot; LC_MESSAGES=&quot;C&quot; LC_MONETARY=&quot;C&quot; LC_NUMERIC=&quot;C&quot; LC_TIME=&quot;C&quot; LC_ALL= 查看服务器的配置： LANG=en_US.UTF-8 LC_CTYPE=&quot;en_US.UTF-8&quot; LC_NUMERIC=&quot;en_US.UTF-8&quot; LC_TIME=&quot;en_US.UTF-8&quot; LC_COLLATE=&quot;en_US.UTF-8&quot; LC_MONETARY=&quot;en_US.UTF-8&quot; LC_MESSAGES=&quot;en_US.UTF-8&quot; LC_PAPER=&quot;en_US.UTF-8&quot; LC_NAME=&quot;en_US.UTF-8&quot; LC_ADDRESS=&quot;en_US.UTF-8&quot; LC_TELEPHONE=&quot;en_US.UTF-8&quot; LC_MEASUREMENT=&quot;en_US.UTF-8&quot; LC_IDENTIFICATION=&quot;en_US.UTF-8&quot; LC_ALL= 物理机会传递 LC_CTYPE 参数给服务器，从而修改了服务器上的 LC_CTYPE 参数，导致服务器不认识。 所以，可以禁用终端传递该参数。 解决方案2方案1不是很完美，只是在逃避问题。还存在乱码问题 仔细想一想，这类问题是由于服务器和本机的 locale 配置不一样。 只要保持本地的和服务器的一致就可以了。 我使用的是 iterm2终端，对应的配置文件 .bash_profile或.bashrc文件。 只需要加入如下两行内容即可： export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 locale 分别再服务器和本机上执行，输出类似的结果： LANG=&quot;en_US.UTF-8&quot; LC_COLLATE=&quot;en_US.UTF-8&quot; LC_CTYPE=&quot;en_US.UTF-8&quot; LC_MESSAGES=&quot;en_US.UTF-8&quot; LC_MONETARY=&quot;en_US.UTF-8&quot; LC_NUMERIC=&quot;en_US.UTF-8&quot; LC_TIME=&quot;en_US.UTF-8&quot; LC_ALL=&quot;en_US.UTF-8&quot; 此时，不会乱码，也不会存在那个警告了。","categories":[{"name":"字符编码","slug":"字符编码","permalink":"http://blog.cuteximi.com/categories/字符编码/"}],"tags":[]},{"title":"运行gulp项目报错：AssertionError: Task function must be specified","slug":"运行gulp项目报错：AssertionError-Task-function-must-be-specified","date":"2018-10-13T03:12:57.000Z","updated":"2018-10-13T03:21:16.395Z","comments":true,"path":"运行gulp项目报错：AssertionError-Task-function-must-be-specified/","link":"","permalink":"http://blog.cuteximi.com/运行gulp项目报错：AssertionError-Task-function-must-be-specified/","excerpt":"","text":"问题描述今天像往常一样，编写文章，并使用gulp bulid压缩代码，但是一运行：gulp build 就出现了这个错误：AssertionError: Task function must be specified。 gulp项目需要全局安装gulp和项目内安装gulp，通过 gulp -v 查看全局gulp 和本地项目的gulp版本： 这俩显然，不一致。 下面，我们可以看到项目里记录的gulp的版本号： 解决可以卸载修改json文件里面的版本号：为gulp 3 版本。如 3.9.1 重新运行 npm install gulp 3 和 gulp 4运行方式是不一样的，所以会出现错误。具体细节，可以看这里 gup3 VS gulp4 区别 Gulp 4最大的变化就是你不能像以前那样传递一个依赖任务列表。 Gulp3，如果有一个任务A，B和C的列表，你想在一个序列中运行（确保A在B开始之前完成，而B在C开始之前完成），代码如下： gulp.task(&#39;a&#39;, function () { // Do something. }); gulp.task(&#39;b&#39;, [&#39;a&#39;], function () { // Do some stuff. }); gulp.task(&#39;c&#39;, [&#39;b&#39;], function () { // Do some more stuff. }); 在Gulp 4中，你不能再这样做了。你会得到以下错误： assert.js:85 throw new assert.AssertionError({ ^ AssertionError: Task function must be specified at Gulp.set [as _setTask] (/home/hope/web/node_modules/undertaker/lib/set-task.js:10:3) at Gulp.task (/home/hope/web/node_modules/undertaker/lib/task.js:13:8) at Object.&lt;anonymous&gt; (/home/hope/web/gulpfile.js:31:6) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.require (module.js:497:17) at require (internal/module.js:20:19) 不要用Gulp3的方式指定依赖任务，你需要使用gulp.series和gulp.parallel，因为gulp任务现在只有两个参数。 gulp.series：按照顺序执行gulp.paralle：可以并行计算 gulp.task(&#39;my-tasks&#39;, gulp.series(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, function() { // Do something after a, b, and c are finished. })); gulp.task(&#39;build&#39;, gulp.parallel(&#39;styles&#39;, &#39;scripts&#39;, &#39;images&#39;, function () { // Build the website. })); 或者这样 gulp.task(&#39;my-tasks&#39;, gulp.series(&#39;a&#39;, gulp.parallel(&#39;styles&#39;,&#39;scripts&#39;, &#39;images&#39;), &#39;b&#39;, &#39;c&#39;, function() { // Do something after a, b, and c are finished. })); 相关任务必须在被调用之前发生。 参考：https://github.com/gulpjs/gulp/blob/master/docs/API.mdhttps://www.fastless.com/gulp-4https://www.jianshu.com/p/40b99bed3127","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://blog.cuteximi.com/tags/gulp/"}]},{"title":"make 和 make install 的区别","slug":"make和makeinstall的区别","date":"2018-10-13T03:10:21.000Z","updated":"2018-10-13T03:32:21.253Z","comments":true,"path":"make和makeinstall的区别/","link":"","permalink":"http://blog.cuteximi.com/make和makeinstall的区别/","excerpt":"","text":"简单来说，make 是编译，make install 是安装… 总结：linux编译安装中configure、make和make install各自的作用 ./configure是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。 make是用来编译的，它从Makefile中读取指令，然后编译。 make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。 1、configure 这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure --prefix=/usr上面的意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin.同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。 2、make 这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或Python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。make 的作用是开始进行源代码编译，以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能，比如 make install 一般表示进行安装，make uninstall 是卸载，不加参数就是默认的进行源代码编译。make 是 Linux 开发套件里面自动化编译的一个控制程序，他通过借助 Makefile 里面编写的编译规范进行自动化的调用 gcc 、ld 以及运行某些需要的程序进行编译的程序。一般情况下，他所使用的 Makefile 控制代码，由 configure 这个设置脚本根据给定的参数和系统环境生成。 3、make install 这条命令来进行安装（当然有些软件需要先运行 make check 或 make test来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）","categories":[{"name":"编译程序","slug":"编译程序","permalink":"http://blog.cuteximi.com/categories/编译程序/"}],"tags":[]},{"title":"原版英文书籍《Linux命令行》阅读记录7-一些键盘按键技巧","slug":"原版英文书籍《Linux命令行》阅读记录7-一些键盘按键技巧","date":"2018-10-13T03:08:02.000Z","updated":"2018-10-13T03:08:24.260Z","comments":true,"path":"原版英文书籍《Linux命令行》阅读记录7-一些键盘按键技巧/","link":"","permalink":"http://blog.cuteximi.com/原版英文书籍《Linux命令行》阅读记录7-一些键盘按键技巧/","excerpt":"","text":"使用命令行不代表我们需要频繁的输入一些命令，有时候bash的一些特性使得我们会更加的懒惰，本章节将带领导学习几个好用的命令。这些命令使我们的操作更加高效。 clear history 命令行编辑bash 使用了一个叫做 readline 的库，来实现命令行的编辑。下面介绍一个常用的快捷方式 移动光标Ctrl + a 光标移动到最开始的位置Ctrl + e 光标一定到结束的位置Ctrl + f 移动光标从开始的位置向结束的位置Ctrl + h移动光标从结束的位置向开始的位置Alt + f 移动一个词汇的距离，向结束的方向Alt + h 移动一个词汇的距离，向开始的方向Ctrl + l 清空屏幕上的命令 编辑命令Ctrl + d删除命令 自动补全当你输入一个命令的时候，按 tab 可以提示或者自动补全该命令。当然，除此之外，tab 键还可以自动补全路径名。 历史命令一般情况下，bash 会记录我们最近输入的 500 个命令 在终端输入 history 命令之后，会显示最近的命令，以数字开头代表序号，第几个命令；使用 ！数字 来重复执行数字代表的那跳命令。","categories":[{"name":"Linux命令行","slug":"Linux命令行","permalink":"http://blog.cuteximi.com/categories/Linux命令行/"}],"tags":[]},{"title":"原版英文书籍《Linux命令行》阅读记录6-重定向","slug":"原版英文书籍《Linux命令行》阅读记录6-重定向","date":"2018-10-13T03:07:05.000Z","updated":"2018-10-13T03:07:24.143Z","comments":true,"path":"原版英文书籍《Linux命令行》阅读记录6-重定向/","link":"","permalink":"http://blog.cuteximi.com/原版英文书籍《Linux命令行》阅读记录6-重定向/","excerpt":"","text":"重定向，回忆一下这个概念是不是之前学过：在 Java web 开发中请求的重定向。在本章节中，我们要学的是“IO重定向”。本文将从以下命令开始展开： cat sort uniq grep wc head tail tee I/O 重定向允许我们更改输出地点和输入来源。一般地，输出送到屏幕，输入来自键盘， 但是通过 I/O 重定向，我们可以做出改变。我们使用 “&gt;” 重定向符后接文件名将标准输出重定向到除屏幕 以外的另一个文件。为什么我们要这样做呢？因为有时候把一个命令的运行结果存储到 一个文件很有用处。例如，我们可以告诉 shell 把 ls 命令的运行结果输送到文件 ls-output.txt 中去， 由文件代替屏幕。 [me@linuxbox ~]$ ls -l /usr/bin &gt; ls-output.txt 这样，我们就把 bin 目录下的详细信息重定向到了文件 ls-output.txt 了，并且有内容。 技巧：单纯的使用&gt; ls-output.txt 这个命令可以清空一个存在的文件或者创建一个文件。 符号每次都是从头开始写。那么，如果我们想追加文件内容怎么办呢？ 使用&gt;&gt; 符号。也就是每次都是在文件末尾添加内容，不会覆盖之前的内容。 如果，现在需要把标准输出和标准输出错误都重定向到文件中，可以使用 ls -l /bin/usr &> ls-output.txt cat 连接文件cat 命令读取一个或多个文件，然后复制到标准输出。cat 经常用来显示简短的文件，cat 可以连接多个文件。比如我们下载了一个大型文件，文件被分成了还几个小文件，可以使用 cat 命令把它们连接起来。例子： cat file-1.* &gt;file-1 管道管道操作符|,一个命令的标准输出可以通过管道送至另一个命令的标准输入。 例子： ls -l /usr/bin | less 过滤器（管道线）管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后 输出它。 uniq 去掉重复的行uniq 命令经常和 sort 命令结合在一起使用 默认情况下，从数据列表中删除任何重复行。但是如果我们想看到 重复的数据列表，让 uniq 命令带上-d选项 wc 打印行数、字数和字节默认显示三个数据，如果加上参数 -l 就只显示行数。例子：统计 /bin 和 /usr/bin 有序程序列表的个数 ls /bin /usr/bin | sort | uniq | wc -l grep 打印匹配行grep 是个很强大的程序，用来找到文件中的匹配文本。 用法也很简单:grep pattern [file...] grep 有一些方便的选项：”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。 head / tail 打印开头或者结尾默认情况下两个命令都打印 10 行。通过参数 -n 来控制打印的行数。 tail 有一个选项允许你实时地浏览文件。使用-f选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。 tee 用来捕捉管道线某个时期的数据tee 程序从标准输入读入数据，并且同时复制数据 到标准输出和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。例子： ls /usr/bin | tee ls.txt | grep zip 这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：","categories":[{"name":"Linux命令行","slug":"Linux命令行","permalink":"http://blog.cuteximi.com/categories/Linux命令行/"}],"tags":[]},{"title":"原版英文书籍《Linux命令行》阅读记录5-使用命令","slug":"原版英文书籍《Linux命令行》阅读记录5-使用命令","date":"2018-10-13T03:06:12.000Z","updated":"2018-10-13T03:06:48.603Z","comments":true,"path":"原版英文书籍《Linux命令行》阅读记录5-使用命令/","link":"","permalink":"http://blog.cuteximi.com/原版英文书籍《Linux命令行》阅读记录5-使用命令/","excerpt":"","text":"背景：阅读英文原作只为了更好地理解书中的精髓，当然也是为了更好地掌握书中的技巧。我们会坚持阅读全书，并记录书中的精髓。 在前面的章节里，我们学到的都是一些神秘的命令，我们不知道他们怎么来的，不过接下来我们会试图去掉一些神秘性，甚至创建我们自己的命令！ 本章节我们将学习一下命令：一起来揭开命令的神秘面纱吧！ type which man whatis alias 到底什么是命令书中总结了四种情况： 1.是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 这一类程序可以是用诸如 C 和 C++语言写成的程序编译的二进制文件, 也可以是由诸如shell，perl，python，ruby等等脚本语言写成的程序 。 2.是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，cd 命令，就是一个 shell 内部命令。 3.是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在， 仅仅意识到它们的存在就可以了。 4.是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。 识别命令既然，给出了上面四种形式的命令，当然提供了一个识别命令的命令！ type 如图所示：使用 type 命令查看如下几个命令的类型。 可以看出 type cd 是 shell 内建的命令。mv 是一个可执行程序，这里的 ll 是一个命令的别名。 which 显示一个可执行程序的位置在大型的系统中，命令很多，需要确认命令的具体位置，可以使用 which 来确认可执行命令的具体位置。 man 显示使用手册下表是man 操作手册的章节说明：可以指定打开某一章节 章节 内容 1 用户命令 2 程序接口内核系统调用 3 C 库函数程序接口 4 特殊文件，比如说设备结点和驱动程序 5 文件格式 6 游戏娱乐，如屏幕保护程序 7 其他方面 8 系统管理员命令 whatis 一句话描述命令有时候你不是很懂某一个命令怎么描述，可以使用 whatis 命令来显示一句话描述： whatis mv mv(1) move(rename) files 使用别名命令使用 alias 命令来创建别名。 为什么使用别名呢，有时候我们输入一系列复杂的命令来达到我们想要的结果，使用别名就可以封装复杂的命令，暴露出简单的命令提供给我们使用。命令格式：alias name=&#39;string&#39;例子：alias foo=&#39;cd /usr; ls; cd -&#39; 删除别名 unalias name 在 shell 中新建别名的时候，关闭这个会话之后，下一次就失效了，要想持久化别名，在之后的会话中也能使用，可以在配置文件（比如：.bash_profile）中： 推荐阅读原版英文书籍《Linux命令行》阅读记录1 原版英文书籍《Linux命令行》阅读记录2 原版英文书籍《Linux命令行》阅读记录3 原版英文书籍《Linux命令行》阅读记录4 原版英文书籍《Linux命令行》阅读记录5 原版英文书籍《Linux命令行》阅读记录6 原版英文书籍《Linux命令行》阅读记录7","categories":[{"name":"Linux命令行","slug":"Linux命令行","permalink":"http://blog.cuteximi.com/categories/Linux命令行/"}],"tags":[]},{"title":"原版英文书籍《Linux命令行》阅读记录4-操作文件和目录","slug":"原版英文书籍《Linux命令行》阅读记录4-操作文件和目录","date":"2018-10-13T03:05:17.000Z","updated":"2018-10-13T03:05:42.338Z","comments":true,"path":"原版英文书籍《Linux命令行》阅读记录4-操作文件和目录/","link":"","permalink":"http://blog.cuteximi.com/原版英文书籍《Linux命令行》阅读记录4-操作文件和目录/","excerpt":"","text":"背景：阅读英文原作只为了更好地理解书中的精髓，当然也是为了更好地掌握书中的技巧。我们会坚持阅读全书，并记录书中的精髓。 从本章节开始，开始真正的实战。 主要学习以下命令： cp mv mkdir rm ln 一些练习以上命令用来操作文件和目录。 图形化界面，可以简单且轻松的完成文件的复制粘贴等操作，为什么我们还要学习使用命令行呢？一些简单的任务，图形化界面更占优势，但是当遇到很复杂的操作时，使用命令行更加方便。比如复制当前目录下以 .html 结尾的文件，图形化界面是不是要一个一个用手去选择？命令行就很简单了 cp -u *.html destination 通配符在开始学习上述命令之前，先来了解一下通配符的重要性以及用法。因为 shell 频繁地使用 文件名，shell 提供了特殊字符来帮助你快速指定一组文件名。这些特殊字符叫做通配符。列一个表格： 通配符 意义 * 匹配任意多个字符（包括零个或一个） ? 匹配任意一个字符（不包括零个） [characters] 匹配任意一个属于字符集中的字符 [!characters] 匹配任意一个不是字符集中的字符 [[:class:]] 匹配任意一个属于指定字符类中的字符 普遍使用的字符类：|字符类|意义||–|–||[:alnum:]|匹配任意的字母或数字||[:alpha:]|匹配任意的字母||[:digit:]|匹配任意一个数字||[:lower:]|匹配任意一个小写字母||[:upper:]|匹配任意一个大写字母| 我们可以借助通配符来构建复杂的文件名查找规则。下面举一些例子： 代表查找所有文件g* 代表查找所有以 “g” 开头的文件b*.txt 代表查找以 “b” 开头，中间任意字符，以 .txt 结尾的文件Data??? 代表查找以 Data 开头，后面紧跟 3 个字符的文件[a, b, c]* 代表查找以 a 或 b 或 c 开头的文件g[0-9][0-9][0-9] 代表查找以 g 开头，并且紧跟着三个数字的文件[[:lower:]123] 代表查找以小写字母结尾 或者 以 1 或 2 或 3 结尾的文件mkdir 创建目录用法： mkdir directory... mkdir dir 此时会创建一个目录，名为 dir。 注意表示法: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复，就像这样： mkdir dir1 dir2 dir3 此时会创建三个目录，名为 dir1, dir2, dir3。 有用的参数说明： -m 指定权限-p 用于创建多级目录，若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录 cp 复制文件和目录复制，有两种用法:1.复制单个项目2.复制多个项目 cp item1 item2 复制 文件或目录 item1 到文件或目录 item2 cp item... directory 复制多个项目到一个目录下。 有用的参数： -a , –archive , 复制文件时，带上属性。-i , –interactive, 重写文件之前，会提示用户是否重写，默认 cp 是重写文件的。-r , –recursive , 递归地复制目录以及目录里面的内容。-u , –update ，当把文件从一个目录复制到另一个目录中时，只复制不存在的文件。或者文件内容更新于已存在的文件中。-v, –verbose, 显示详细的复制操作。 cp 命令的几个例子展示： cp file1 file2 如果file2 存在的话，cp 命令把 file1 的内容重写到 file2 中。如果 file2 不存在，则创建。 cp -i file1 file2 如果 file2 存在，在重写之前会提示用户确认 “是否重写？”，其他的，同上。 cp file1 file2 dir1 复制 file1 和 file2 到目录 dir1 中，目录 dir1 必须存在。 cp dir1/* dir2 使用通配符，将 dir1目录下的内容全部复制到 dir2 目录下，目录 dir2 必须存在。 cp -r dir1 dir2 复制目录 dir1 中的内容到目录 dir2目录中，目录 dir 不存在则创建。 mv 移动和重命名mv 的使用方法和 cp 一样。 mv item1 item2 移动（重命名）item1 为 item2 mv item... directory 移动多个项目到一个目录下。 有用的参数： -i , –interactive, 重写文件之前，会提示用户是否重写，默认 cp 是重写文件的。-u , –update ，当把文件从一个目录移动到另一个目录中时，只移动不存在的文件。或者文件内容更新于已存在的文件中。-v, –verbose, 显示详细的操作信息。 mv的例子： mv file1 file2 如果file2 存在的话，cp 命令把 file1 的内容重写到 file2 中。如果 file2 不存在，则创建。 mv -i file1 file2 如果 file2 存在，在重写之前会提示用户确认 “是否重写？”，其他的，同上。 mv file1 file2 dir1 移动 file1 和 file2 到目录 dir1 中，目录 dir1 必须存在。 mv dir1 dir2 如果目录 dir2 不存在，则创建目录 dir2 ，并且移动 dir1 的内容到目录 dir2 中，同时删除目录 dir1 。如果存在 dir2 , 移动目录 dir1以及它的内容到目录 dir2 。 rm 删除文件和目录rm 命令用来删除文件和目录。 rm item... 前面提到过这种表达方式，代表参数可以一个或多个，可以删除一个或多个项目。 有用的参数 -i, –interactive, 删除的时候，提示用户确认信息，如果不带此参数，rm 会默默直接删掉文件。-r, –recursive, 递归的删除文件。要删除目录时，必须要指定此参数，代表全部清空。-f, –force, 忽视不存在的信息，不显示提示信息，会覆盖 -i参数-v，verbose, 显示详细的操作信息。 提个醒！ 类 Unix 的操作系统，比如说 Linux，没有复原命令。一旦你用 rm 删除了一些东西， 它就消失了。Linux 假定你很聪明，你知道你在做什么。尤其要小心使用通配符。 ln 创建链接ln 既可以创建硬链接，也可以创建符号链接（软链接）。 硬链接是最初 Unix 创建链接的方式。每个文件都默认都有一个硬链接，这个硬链接给予文件名字。我们每建立一个硬链接，都相当于新增一个额外的目录项。硬链接有两个额外的局限性：1.一个硬链接不能关联不同文件系统 的文件。2.硬链接不能关联目录 符号链接是为了解决上述局限性，通过创建一个特殊类型的文件，这个文件包含一个关联文件或目录的文件指针。这种方式和 Windows 的快捷方式差不多，但是比 Windows 要早很多年！删除符号链接的时候，只是链接被删除，而不是文件本身。如果文件先被删除，链接依然会存在，只是不指向任何东西。 练习首先创建一个领地，执行命令 mkdir playground [me@linuxbox ~]$ mkdir playground 然后，进入 playground 目录创建两个目录 dir1 和 dir2 [me@linuxbox ~]$ cd playground [me@linuxbox playground]$ mkdir dir1 dir2 接下来，复制一些数据来这个目录。 [me@linuxbox playground]$ cp /etc/passwd . 再次执行上面的命令，只不过这一次加上了参数 -v 来显示详细的操作信息： [me@linuxbox playground]$ cp -v /etc/passwd . `/etc/passwd&#39; -&gt; `./passwd&#39; 如果换成参数 -i 会显示上面呢？来试试 [me@linuxbox playground]$ cp -i /etc/passwd . cp: 是否覆盖 &#39;./passwd&#39;? 接着输入 y 就会被重写，输入背的字符（n什么的），会保留。 这样，我们就有了 一个 playground 目录下 有一个文件 passwd和 两个目录 dir1 和dir2 。 我们给 passwd 改一个名字：改成 dog [me@linuxbox playground]$ mv passwd dog 首先把 dog 文件移动到 dir1 木目录中。 me@linuxbox playground]$ mv dog dir1 接着把 dir1 移动到目录 dir2 中。 me@linuxbox playground]$ mv dir1 dir2 因为 dir2 存在，所以 dir1 以及它里面的内容都会移动到 dir2中。如果 dir2 不存在， dir1 会重命名为 dir2 。 最后将 dog 文件再移动到 playground 目录下。 me@linuxbox playground]$ cd dir2/dir1 me@linuxbox dir1]$ mv dog ~/playround 建立符号链接（软链接） me@linuxbox playground]$ ln -s /home/me/playground/dog dog-system 使用ll,查看一下： lrwxrwxrwx 1 me me 6 2008-01-15 15:17 dog-system -&gt; /home/me/playground/dog 根据我们前面所学的文件解析，可知这一个符号链接文件，指向 /home/me/playground/dog 文件。 提示：创建符号链接的时候，最好使用绝对路径。 上面演示的是创建文件的符号链接，同样也可以创建的目录的符号链接。 对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。 而 rm 命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。","categories":[{"name":"Linux命令行","slug":"Linux命令行","permalink":"http://blog.cuteximi.com/categories/Linux命令行/"}],"tags":[]},{"title":"原版英文书籍《Linux命令行》阅读记录3-解析文件的描述含义和阅读文件","slug":"原版英文书籍《Linux命令行》阅读记录3-解析文件的描述含义和阅读文件","date":"2018-10-13T03:04:37.000Z","updated":"2018-10-13T03:04:59.015Z","comments":true,"path":"原版英文书籍《Linux命令行》阅读记录3-解析文件的描述含义和阅读文件/","link":"","permalink":"http://blog.cuteximi.com/原版英文书籍《Linux命令行》阅读记录3-解析文件的描述含义和阅读文件/","excerpt":"","text":"背景：阅读英文原作只为了更好地理解书中的精髓，当然也是为了更好地掌握书中的技巧。我们会坚持阅读全书，并记录书中的精髓。 深入研究长格式输出上一篇文章讲到 ls 命令加上 -l 就会输出详细的长格式信息。类似于这样的： -rw-r--r-- 1 root wheel 5 Apr 5 19:22 .CFUserTextEncoding -r--r--r-- 1 root wheel 10 Oct 3 2017 .forward drwxr-xr-x 3 root wheel 96 Mar 16 2018 .oracle_jre_usage -rw------- 1 root wheel 3667 Sep 30 10:05 .sh_history drwx------ 3 root wheel 96 Sep 18 22:02 .ssh -rw------- 1 root wheel 15886 Aug 30 19:37 .viminfo drwx------ 15 root wheel 480 Mar 15 2018 Library 我会依次讲解每个部分的大概。以第一行的数据为例：-rw-r--r-- 1 root wheel 5 Apr 5 19:22 .CFUserTextEncoding第一部分：-rw-r--r-- ① - 代表文件类型，-代表普通文件，d代表目录。②连续三个字符代表文件所有者的权限③连续字符代表文件所属组的权限④三个字符是文件其他所有人的权限 第二部分：1，代表文件的硬连接数第三部分：root ，文件属于 root 用户第三部分：wheel, 文件属于 wheel 组。第四部分：5 ,文件大小第六部分：Apr 5 19:22 ,文件上一次修改时间第七部分：.CFUserTextEncoding , 文件名字 确认文件类型在 linux 系统中，并不要求文件名称来反映文件内容。用 file 命令来确定文件的类型。 file filename 使用less浏览文件The less command is a program to view text files. 为什么我们要查看文本文件呢？ 因为许多包含系统设置的文件（叫做配置文件），是以文本格式存储的，阅读它们 可以更深入的了解系统是如何工作的。另外，许多系统所用到的实际程序（叫做脚本）也是以这种格式存储的。more 程序只能向前翻页，而 less 程序允许前后翻页 less 命令的使用规则： less filename 运行 less 程序之后，可以使用下面这些命令来浏览文件。 命令 行为 Page UP or b 向上翻滚一页 Page Down or space 向下翻滚一页 UP Arrow 向上翻滚一行 Down Arrow 向下翻滚一行 G 移动到最后一行 1G or g 移动到开头一行 /charaters 向前查找指定的字符串 n 向前查找下一个出现的字符串，这个字符串是之前所指定查找的 h 显示帮助屏幕 q 退出 less 程序 目录 说明 / 根目录，万物起源。 /bin 包含系统启动和运行所必须的二进制程序。 /boot 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。有趣的文件：/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。/boot/vmlinuz，Linux 内核。 /dev 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。 /etc 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件:/etc/crontab， 定义自动运行的任务。/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户帐号列表。 /home 在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。 /lib 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。 /lost+found 每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。 /media 在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。 /mnt 在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。 /opt 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。 /proc 这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。 /root root 帐户的家目录。 /sbin 这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。 /tmp 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录。 /usr 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。 /usr/bin /usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。 /usr/lib 包含由/usr/bin 目录中的程序所用的共享库。 /usr/local 这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。 /usr/sbin 包含许多系统管理程序。 /usr/share /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。 /usr/share/doc 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 /var 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。 /var/log 这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。 符号链接有时候，你会看到输出这样的信息： lrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc.so.6 -&gt; libc-2.6.so 第一个l是什么?为什么有两个文件名呢？其实这是一个特殊的文件，叫做符号链接。 在大多数“类 Unix” 系统中， 有可能一个文件被多个文件名所指向。虽然这种特性的意义并不明显，但它真的很有用。 关于软连接和硬链接的区别以及意义，//todo","categories":[{"name":"Linux命令行","slug":"Linux命令行","permalink":"http://blog.cuteximi.com/categories/Linux命令行/"}],"tags":[]},{"title":"原版英文书籍《Linux命令行》阅读记录2-在文件系统中翱翔!","slug":"原版英文书籍《Linux命令行》阅读记录2-在文件系统中翱翔","date":"2018-10-13T03:03:53.000Z","updated":"2018-10-13T03:04:18.425Z","comments":true,"path":"原版英文书籍《Linux命令行》阅读记录2-在文件系统中翱翔/","link":"","permalink":"http://blog.cuteximi.com/原版英文书籍《Linux命令行》阅读记录2-在文件系统中翱翔/","excerpt":"","text":"背景：阅读英文原作只为了更好地理解书中的精髓，当然也是为了更好地掌握书中的技巧。我们会坚持阅读全书，并记录书中的精髓。 The first thing we need to learn is how to navigate the filesystem on our linux system. In this article I will introduce the following commands: 我们需要学习的第一件事是如何在 Linux 的文件系统中跳转，在本文章中我们介绍如下命令： pwd cd ls 还会介绍文件命名的规则： 以 “.” 字符开头的文件名是隐藏文件，ls 命令不能列出它们， 用 ls -a 命令就可以了。 文件名和命令名是大小写敏感的。文件名 “File1” 和 “file1” 是指两个不同的文件名。 Linux 没有“文件扩展名”的概念。 虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限 使用 “.”，“－”，下划线。最重要的是，不要在文件名中使用空格。如果你想表示词与 词间的空格，用下划线字符来代替。 1. 理解文件系统🌲在类 unix 系统中，比如 linux 中，总的只有一个单一的文件系统树，不管有多少个磁盘或者存储设备连接到这个计算机，这些存储设备连接（挂载）到目录树的各个节点上。注意，这是一颗倒置的目录树。 2. 当前目录在图形化界面可以看出目录的层级结构，但是在命令行中，是没有这个概念的，我们就像是在迷宫一样，在任意时刻，我们处在一个目录下，我们当前所处的目录，称作当前目录。我们可以进入上级目录，或者下级目录。 使用 pwd 来显示当前目录。（ print working directory 的缩写） [me@linuxbox ~]$ pwd /home/me 3. 列出目录的内容To list the files and directories in the current working directory, we use the ls command. [me@linuxbox ~]$ ls Desktop Documents Music Pictures Public Templates Videos 单独一个 ls 是默认列出当前目录下的内容，当然也可以在后面指定目录。比如，ls /usr 指定列出 /usr 目录下的内容。 介绍 ls 一些常用的参数：|选项 | 说明 || – | –||ls -a | 显示隐藏文件 ||ls -l | 显示更详细的信息||ls -d| ls -d -l 目录 直接显示这个目录的详情，而不是显示这个目录里面的内容||ls 目录1 目录2 | 可以列出多个目录下的内容||ls -t | 按照修改时间排序||ls -S | 按照文件大小排序||ls -h | 显以人类可读的形式显示文件大小||ls -r | 反序| 4. 切换目录（更改当前工作目录）切换目录我们使用命令：cd 是 change directory 的缩写。 4.1 绝对路径An absolute pathname begins with the root directory.绝对路径开始于根目录 / 4.2 相对路径A relative pathname starts from the working directory.相对路径始于当前工作目录。 为了做到这个（用相对路径表示）， 我们在文件系统树中用一对特殊符号来表示相对位置。 这对特殊符号是 “.” (点) 和 “..” (点点)。 符号 “.” 指的是工作目录，”..” 指的是工作目录的父目录 4.3 演示🌰1：使用绝对路径，进入 bin 目录下 [me@linuxbox ~]$ cd /usr/bin [me@linuxbox bin]$ pwd /usr/bin 🌰2：使用相对路径 [me@linuxbox ~]$ cd /usr # 绝对路径 [me@linuxbox usr]$ cd ./bin # 相对路径 [me@linuxbox bin]$ pwd /usr/bin 小结：有一件很重要的事，我必须指出来。在几乎所有的情况下，你可以省略”./”。它是隐含的。 所以上面的例子，也可以这样写：省掉 ./ [me@linuxbox ~]$ cd /usr # 绝对路径 [me@linuxbox usr]$ cd bin # 相对路径,省掉了 ./ [me@linuxbox bin]$ pwd /usr/bin 有用的参数：| 操作 | 说明 || ———- | —— || cd - | 跳到先前的工作目录 || cd ~username| 跳转到用户主目录，cd ~ximi 跳转到 ximi 用户的 home 目录| 自行练习一下吧…","categories":[{"name":"Linux命令行","slug":"Linux命令行","permalink":"http://blog.cuteximi.com/categories/Linux命令行/"}],"tags":[]},{"title":"原版英文书籍《Linux命令行》阅读记录1-什么是shell?","slug":"原版英文书籍《Linux命令行》阅读记录1-什么是shell","date":"2018-10-13T03:02:33.000Z","updated":"2018-10-13T03:03:13.618Z","comments":true,"path":"原版英文书籍《Linux命令行》阅读记录1-什么是shell/","link":"","permalink":"http://blog.cuteximi.com/原版英文书籍《Linux命令行》阅读记录1-什么是shell/","excerpt":"","text":"背景：阅读英文原作只为了更好地理解书中的精髓，当然也是为了更好地掌握书中的技巧。我们会坚持阅读全书，并记录书中的精髓。 1. 理解 Linux 的 “自由”Many people speak of “freedom” with regard to Linux. Freedom is the power to decide what your computer does and the only way to have this freedom is to know what your computer is doing. Freedom is a computer that is without any secrets, one where everything can be known if you care enough to find it. 很多人一说到Linux, 就会说自由。但是你真的而理解这种自由吗？这种自由是一种权力，能够决定你的计算机干什么，获取这种自由的唯一方式就是知道你的计算机在做什么。自由就是你的计算机没有任何㊙️，你可以从计算机那里了解一切，只要你用心去寻找。 2. 什么是 shellWe speak of the command line, we are really referring to the shell. The shell is a program that takes keyboard commands and passes them to the operating system to carry out. 一说起命令行，我们真正指的是 shell。shell 就是一个程序，把键盘的输入传递给操作系统去执行。 3. 初次相遇 shell第一次见到 shell,你只会看到一行提示符，形如：[me@linuxbox ~]$ This is called a shell prompt and it will appear whenever the shell is ready to accept input. 这叫做 shell 提示符， 无论何时当 shell 准备好接受输入时，就会闲这样的提示符。当然，出现的形式会根据不同的 Linux 发行版有所不同。但是大体上会包含 主机名 用户名 当前目录 和一个美元符号。 🤔另外，如果提示符最后是 # 号，而不是 $，会表示这是一个具有 super root 权限的终端。 3. 一些简单入门的小命令命令历史：使用 ⬆️ 箭头可以浏览以往的命令，以往的命令会重新出现在提示符后面。移动光标：使用 ⬅️ ➡️ 箭头可以移动光标，来更好地编辑命令。时间：date 显示系统当前时间和日期 [me@linuxbox ~]$ date Sun Sep 30 10:02:00 CST 2018 日历：cal 与上一个命令相关，默认显示当前月份的日历。 [me@linuxbox ~]$ cal September 2018 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 查看磁盘剩余空间：df [me@linuxbox ~]$ df Filesystem 512-blocks Used Available Capacity iused ifree %iused Mounted on /dev/disk1s1 489620264 166659552 315340480 35% 945005 9223372036853830802 0% / devfs 385 385 0 100% 666 0 100% /dev /dev/disk1s4 489620264 6291496 315340480 2% 3 9223372036854775804 0% /private/var/vm map -hosts 0 0 0 100% 0 0 100% /net map auto_home 0 0 0 100% 0 0 100% /home /dev/disk2s1 5859376 378616 5480760 7% 2830 4294964449 0% /Volumes/ACDSee /dev/disk3s2 310480 283440 27040 92% 255 4294967024 0% /Volumes/Charles Proxy v4.2.7 ximi:~ taoshilei$ 结束终端会话：exit Note: Don’t be tempted to use Ctrl-c and Ctrl-v to perform copy and paste inside a terminal window. They don’t work. 提示：不要在终端窗口使用 Ctrl-c 和Ctrl-v 来完成复制和粘贴工作。这些不起作用。这两个命令有别的含义，他们早于在微软之前就已经定义了这两个命令的含义，所以不是我们在windows下熟悉的复制粘贴。","categories":[{"name":"Linux命令行","slug":"Linux命令行","permalink":"http://blog.cuteximi.com/categories/Linux命令行/"}],"tags":[]},{"title":"并发编程的艺术之并发编程的挑战","slug":"并发编程的艺术之并发编程的挑战","date":"2018-10-13T02:58:56.000Z","updated":"2018-10-13T03:00:33.067Z","comments":true,"path":"并发编程的艺术之并发编程的挑战/","link":"","permalink":"http://blog.cuteximi.com/并发编程的艺术之并发编程的挑战/","excerpt":"","text":"并发编程的目的是为了让我们的程序变得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。线程不在于多，在并发编程中，我们将面临如下挑战：上下文切换、死锁问题、受限于软硬件资源限制问题。 上下文切换单核CPU是如果实现多线程的呢？ CPU通过给每个线程分配时间片来实现，时间片是分配给线程的时间。因为时间片非常短，所以CPU不停地切换线程执行，我们感觉上是同时执行的。（一般的，时间片只有十几毫秒 ms） 当一个任务执行一个时间片之后，会切换成下一个任务执行，但是切换之前会保存这个任务的状态，以便下次回到这个任务的时候，可以下载上一次的状态，继续执行。这样，一个任务从保存到再加载的过程就是一次上下文切换。 上面给出了时间片 和 上下文切换的解释。不只是计算机遵循这些原则。 拿现实生活中的例子，我们阅读英文书籍，遇到不会的单词，记住读到的位置，然后去查词典，查会了之后，我们回到上次卡住的位置继续阅读。想到回到原来的位置，大脑必须得记住在什么位置。这样周而复始，查单词和读书之间的切换是会影响读书效率的。这样也就不难理解，上下文切换对多线程的影响了。 多线程一定快吗？根据一个代码的实例，来探讨一下这个问题： package com.cuteximi.concurrent; /** * @program: Java-300 * @description: 多线程一定快吗？ * @author: TSL * @create: 2018-10-11 14:22 **/ public class TestConcurrent { private static final long count = 10000; public static void main(String[] args) throws InterruptedException { concurrency(); serial(); } // 并行 private static void concurrency() throws InterruptedException{ long start = System.currentTimeMillis(); Thread thread = new Thread(new Runnable() { @Override public void run() { int a = 0; for (int i = 0;i&lt; count;i++){ a+=5; } } }); thread.start(); int b = 0; for (long i = 0;i&lt;count;i++){ b--; } long time = System.currentTimeMillis() - start; thread.join(); System.out.println(&quot;concurrency: &quot;+time+&quot; ms,b=&quot;+b); } // 串行 private static void serial(){ long start = System.currentTimeMillis(); int a =0; for (long i = 0;i &lt; count;i++){ a+=5; } int b =0; for (long i = 0;i &lt; count;i++){ b--; } long time = System.currentTimeMillis() - start; System.out.println(&quot;Serial &quot;+time+&quot; ms,b=&quot;+b+&quot;,a=&quot;+a); } } 经过不断的修改，上述代码的 count 的值。对比两种方式的执行速度。|count的值|串行方法耗时（ms）|并行方法耗时（ms）|并行比串行快多少||–|–|–|–||1万|0|1|慢||10万|3|4|慢||100万|6|6|差不多||1000万|18|11|快||1亿|160|79|快了一倍多 上表的数据是一个平均值，但是很容易看出多线程就不一定快！那么一开始的时候为什么串行比并行还要快呢？是因为并行存在创建线程和上下文切换的花销。随着数量的扩大，多线程才显示出优势。 我们不得不重视，上下文切换的开销！ 死锁🔐是一个很有用的工具，使用锁的过程中最容易出现的就是死锁，一旦产生死锁就会造成系统不可用。看下面这段代码： package com.cuteximi.concurrent; /** * @program: Java-300 * @description: 死锁的例子 * @author: TSL * @create: 2018-10-11 15:14 **/ public class DeadLockDemo { private static String A = &quot;A&quot;; private static String B = &quot;B&quot;; public static void main(String[] args) { deadLock(); } private static void deadLock(){ // 线程1 Thread t1 = new Thread(new Runnable() { @Override public void run() { synchronized (A){ try { Thread.sleep(2000); }catch (InterruptedException e){ e.printStackTrace(); } synchronized (B){ System.out.println(&quot;111111&quot;); } } } }); // 线程2 Thread t2 = new Thread(new Runnable() { @Override public void run() { synchronized (B){ synchronized (A){ System.out.println(&quot;222222222&quot;); } } } }); t1.start(); t2.start(); } } 执行这段代码的时候，一直结束不了，因为线程1 和线程2在互相等待。 如何避免死锁呢？ 避免一个线程同时获得多把锁。 避免一个线程在🔐内同时获得多个资源。尽量保证每把锁仅占用一个资源。 尝试使用定时锁，使用lock.tryLock（timeout）来代替内部锁。 对于数据库锁，加锁和解锁必须在一个数据库连接里面，否则会出现解锁失败的情况。 资源限制程序执行速度受限于极端及硬件或软件资源，叫做资源限制。 硬件限制：比如 带宽、硬盘读写速度、CPU处理速度等。 软件限制：比如 数据库连接数，sock连接数等。 对于硬件的限制，可以考虑使用集群。比如使用 ODPS、Hadoop或者自己搭建集群。 对于软件资源的限制，可以考虑使用资源池将资源复用。 小结本文主要说明了在并发编程中遇到几个的挑战，建议使用 JDK 并发包中的提供的并发容器和工具类来解决这一类问题。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"http://blog.cuteximi.com/categories/并发编程/"}],"tags":[]},{"title":"优秀的资源推荐","slug":"优秀的资源推荐","date":"2018-10-06T13:01:19.000Z","updated":"2018-10-12T09:09:31.009Z","comments":true,"path":"优秀的资源推荐/","link":"","permalink":"http://blog.cuteximi.com/优秀的资源推荐/","excerpt":"","text":"前言 该篇文章整理自网络，网友一起贡献的优秀的学习网站和资源，谢谢大家。师傅领进门，修行在个人，一起来和优秀的人一起学习进步吧，这些优质的博主和资源是经过时间历练的，当然陶哥也不能藏着掖着啊，好内容当然也要和大家一起分享了。 分类介绍1主要介绍如下几个方面： 优秀的博主。 优秀的社区。 专注某个知识领域的文章。 其实有没有分那么细致，毕竟优秀的人不仅仅在某方面厉害。 1.阮一峰的网络日志：http://www.ruanyifeng.com/blog/ 2.海牛部落：http://www.hainiubl.com/ 高品质的技术社区 3.熔岩： http://blog.51cto.com/lavasoft Java生态技术 4.老赵点滴： http://blog.zhaojie.me/ 打造国内最好的.net技术博客 5.陈皓 ： https://www.coolshell.cn/ 享受编程和技术带来的快乐 6.赖永浩 ： http://laiyonghao.com/ 7.July : https://blog.csdn.net/v_july_v 结构之法、算法之道 8.刘未鹏：http://mindhacks.cn/ 不解释 9.徐宥： https://blog.youxu.info/ 人工智能博士，科普 10.李博杰：https://ring0.me/ 科普系列 公司团队 11.今日头条技术博客： https://techblog.toutiao.com/ 纯技术大佬 12.美团技术团队：https://tech.meituan.com/ 一行代码，亿万生活。非常接地气的文章。 13.阿里巴巴UED资深设计部门：http://www.aliued.com/ 前端的福利 14.Alloy Team : http://www.alloyteam.com/ 腾讯核心技术团队、致力于Web前端技术。 15.Tencent ISUX : https://isux.tencent.com/ 腾讯核心设计团队，负责互联网产品的设计。 社区 16.V2EX : https://www.v2ex.com/ 技术论坛 以上仅为个人觉得值得看的博客和社区等，本文会持续更新，先收藏起来吧。如您有什么好的资源，欢迎评论。查看外链可以选择点击阅读原文。","categories":[{"name":"编程","slug":"编程","permalink":"http://blog.cuteximi.com/categories/编程/"}],"tags":[{"name":"推荐","slug":"推荐","permalink":"http://blog.cuteximi.com/tags/推荐/"}]},{"title":"mac指南","slug":"mac指南","date":"2018-09-24T02:44:54.000Z","updated":"2018-09-24T02:45:31.199Z","comments":true,"path":"mac指南/","link":"","permalink":"http://blog.cuteximi.com/mac指南/","excerpt":"","text":"Mac 开发配置手册手册内容为「如何让一部全新的 MacBook 快速完成开发环境配置」，主要面向 Web 开发者。其中的指导，在 Mavericks 和 Yosemite 上有效，其他版本系统并未尝试。 如果你是一名老手，本手册让你减少配置开发环境的烦恼。 如果你是一名新手，那么恭喜你，你将会认识一个全新的世界。 手册内容主要意译自：Sourabh Bajaj 的 Mac OS X Setup Guide，少部分内容由译者添加和修改。 ##系统设置 在任何的操作系统中，首先你需要做一件事就是更新系统，点击窗口左上角的  &gt; 关于本机 &gt; 软件更新 。此外，如果这是一部新的电脑，你还需要到系统设置进行一些适当调整。如何调整，取决于个人喜好。 触控板系统设置 &gt; 触控板光标与点击✓ 轻拍来点按✓ 辅助点按✓ 查找✓ 三指拖移滚动缩放✓ 默认全选更多手势✓ 默认全选 Dock置于屏幕上的位置：左边设置 Dock 图标更小（大小随个人喜好）✓ 自动显示和隐藏 Dock FinderFinder &gt; 显示显示标签页栏显示路径栏显示状态栏自定工具栏 &gt; 去除所有按钮，仅剩搜索栏Finder &gt; 偏好设置通用开启新 Finder 窗口时打开：HOME「用户名」目录边栏添加 HOME「用户名」目录 和 创建代码文件目录将 共享的(shared) 和 标记(tags) 目录去掉 菜单栏去掉蓝牙等无需经常使用的图标将电池显示设置为百分比 Spotlight去掉字体和书签与历史记录等不需要的内容设置合适的快捷键 互联网帐户添加 iCloud 用户，同步日历，联系人和 Find my mac 等等 XCode从 App store 或苹果开发者网站安装 Xcode 。 紧接着，安装 Xcode command line tools，运行： xcode-select --install 运行命令后，按照指引，你将完成 Xcode command line tools 安装。 如果你不是一名 iOS 或 OS X 开发者，可以跳过安装 XCode 的过程，直接安装 Xcode command line tools 。安装完成后，你将可以直接在 terminal 中使用主要的命令，比如：make, GCC, clang, perl, svn, git, size, strip, strings, libtool, cpp等等。如果你想了解 Xcode command line tools 包含多少可用的命令，可以到 /Library/Developer/CommandLineTools/ 查看。以下为其中的命令列表： ar as asa bison BuildStrings c++ c89 c99 cc clang clang++ cmpdylib codesign_allocate CpMac cpp ctags ctf_insert DeRez dsymutil dwarfdump dyldinfo flex flex++ g++ gatherheaderdoc gcc gcov GetFileInfo git git-cvsserver git-receive-pack git-shell git-upload-archive git-upload-pack gm4 gnumake gperf hdxml2manxml headerdoc2html indent install_name_tool ld lex libtool lipo lldb lorder m4 make MergePef mig mkdep MvMac nasm ndisasm nm nmedit otool pagestuff projectInfo ranlib rebase redo_prebinding ResMerger resolveLinks Rez RezDet RezWack rpcgen segedit SetFile size SplitForks strings strip svn svnadmin svndumpfilter svnlook svnrdump svnserve svnsync svnversion unifdef unifdefall UnRezWack unwinddump what xml2man yaccHomebrew 包管理工具可以让你安装和更新程序变得更方便，目前在 OS X 系统中最受欢迎的包管理工具是 Homebrew. 安装在安装 Homebrew 之前，需要将 Xcode Command Line Tools 安装完成，这样你就可以使用基于 Xcode Command Line Tools 编译的 Homebrew。 在 terminal 中复制以下命令（不包括 $），跟随指引，将完成 Hombrew 安装。 $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 紧接着，我们需要做一件事让通过 Homebrew 安装的程序的启动链接 (在 /usr/local/bin中）可以直接运行，无需将完整路径写出。通过以下命令将 /usr/local/bin 添加至 $PATH 环境变量中: $ echo &#39; export PATH=&quot;/usr/local/bin:$PATH&quot; &#39; &gt;&gt; ~/.bash_profile Cmd+T 打开一个新的 terminal 标签页，运行以下命令，确保 brew 运行正常。 $ brew doctor 译注： 安装完成后，Homebrew 会将本地 /usr/local 初始化为 git 的工作树，并将目录所有者变更为当前所操作的用户，将来 brew 的相关操作不需要 sudo 。 Homebrew 基本使用安装一个包，可以简单的运行：$ brew install &lt;package_name&gt;更新 Homebrew 在服务器端上的包目录：$ brew update查看你的包是否需要更新：$ brew outdated更新包： $ brew upgrade &lt;package_name&gt;Homebrew 将会把老版本的包缓存下来，以便当你想回滚至旧版本时使用。但这是比较少使用的情况，当你想清理旧版本的包缓存时，可以运行：$ brew cleanup查看你安装过的包列表（包括版本号）：$ brew list –versions Homebrew Cask你已经感受到了使用 Homebrew 安装命令行程序的便利。那么接下来，我们将通过 Homebrew Cask 优雅、简单、快速的安装和管理 OS X 图形界面程序，比如 Google Chrome 和 Dropbox。 安装安装 Homebrew-cask 是如此的简单直接，运行以下命令即可完成： $ brew install caskroom/cask/brew-cask $ brew cask install google-chrome // 安装 Google 浏览器 $ brew update &amp;&amp; brew upgrade brew-cask &amp;&amp; brew cleanup // 更新 搜索如果你想查看 cask 上是否存在你需要的 app，可以到 caskroom.io 进行搜索。 文件预览插件有些 插件 可以让 Mac 上的文件预览更有效，比如语法高亮、markdown 渲染、json 预览等等。 $ brew cask install qlcolorcode $ brew cask install qlstephen $ brew cask install qlmarkdown $ brew cask install quicklook-json $ brew cask install qlprettypatch $ brew cask install quicklook-csv $ brew cask install betterzipql $ brew cask install webpquicklook $ brew cask install suspicious-package OS X 图形界面程序$ brew cask install alfred $ brew cask install appcleaner $ brew cask install cheatsheet $ brew cask install dropbox $ brew cask install google-chrome $ brew cask install onepassword $ brew cask install sublime-text $ brew cask install totalfinder ... 译注： 译者本人并不喜欢 brew cask 的安装方式，更倾向于到 App Store 或官方下载 OS X 图形界面程序。主要因为名字不好记忆、偶尔需要手动更新，另外当你使用 Alfred 或 Spotlight ，你将发现将程序安装在 ~/Application 会很方便。 iTerm2作为一名开发者，我们常常花上很多时间在终端 上，如同武士的剑，一出手便知高低。所以让我们安装 Mac 上最强大的终端 iTerm2 吧！写码除虫，居家必备。 在 Finder 中，将 iTerm 拖拽进入 Application 文件夹中。然后，你可以在 Launchpad 中启动 iTerm。 颜色和字体设置 在 Keys -&gt; Hotkey 中设置 command + option + i 快速显示和隐藏 iTerm 在 Profiles -&gt; Default -&gt; Check silence bell 下载 Solarized dark iterm colors，在 Profiles -&gt; Default -&gt; Colors -&gt; Load Presets 将其导入，作为默认颜色。 在 Profiles -&gt; Text 改变游标（cursor）文字和颜色，随个人喜好。 更多设置，可参考 打造好用的终端 Zsh我们将安装 zsh ，其拓展功能和主题将由 oh-my-zsh 提供。其中Env.sh 文件用于维护别名（aliases），输出（exports）和路径改变（path changes）等等，以免影响 ~/.zshrc。Zsh使用 Homebrew 完成 zsh 和 zsh completions 的安装 brew install zsh zsh-completions安装 oh-my-zsh 让 zsh 获得拓展功能和主题 curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh用文本编辑器或 vi 打开 .zshrc 进行以下编辑: ZSH_THEME=pygmalion alias zshconfig=”vi ~/.zshrc” alias envconfig=”vi ~/Projects/config/env.sh” plugins=(git colored-man colorize github jira vagrant virtualenv pip python brew osx zsh-syntax-highlighting)用文本编辑器或 vi 打开 ~/Projects/config/env.sh 进行以下编辑: #!/bin/zsh # PATH export PATH=&quot;/usr/local/share/python:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin&quot; export EDITOR=&#39;vi -w&#39; # export PYTHONPATH=$PYTHONPATH # export MANPATH=&quot;/usr/local/man:$MANPATH&quot; # Virtual Environment export WORKON_HOME=$HOME/.virtualenvs export PROJECT_HOME=$HOME/Projects source /usr/local/bin/virtualenvwrapper.sh # Owner export USER_NAME=&quot;YOUR NAME&quot; eval &quot;$(rbenv init -)&quot; # FileSearch function f() { find . -iname &quot;*$1*&quot; ${@:2} } function r() { grep &quot;$1&quot; ${@:2} -R . } #mkdir and cd function mkcd() { mkdir -p &quot;$@&quot; &amp;&amp; cd &quot;$_&quot;; } # Aliases alias cppcompile=&#39;c++ -std=c++11 -stdlib=libc++&#39; 译注： 如果是新增环境变量或者是修改环境变量的值，都需要 source 一下才能立即生效。如果是删除一个环境变量，必须输入 exit 以 logout 当前 shell ，然后再重新打开一个新的 shell 并 login 才能生效。 Git and Github作为一名开发者怎么可能没有 Git 呢? 我们马上就来安装： $ brew install git 好的，现在我们来测试一下 git 是否安装完好： $ git --version 运行 $ which git 将会输出 /usr/local/bin/git. 接着，我们将定义你的 Git 帐号（与你在 GitHub 使用的用户名和邮箱一致） $ git config --global user.name &quot;Your Name Here&quot; $ git config --global user.email &quot;your_email@youremail.com&quot; 这些配置信息将会添加进 ~/.gitconfig 文件中. 我们将推荐使用 HTTPS 方法（另一个是 SSH），将你的代码推送到 Github 上的仓库。如果你不想每次都输入用户名和密码的话，可以按照此 描述 说的那样，运行： $ git config --global credential.helper osxkeychain 此外，如果你打算使用 SSH方式，可以参考此 链接. Git Ignore创建一个新文件 ~/.gitignore ，并将以下内容添加进去，这样全部 git 仓库将会忽略以下内容所提及的文件。 # Folder view configuration files .DS_Store Desktop.ini # Thumbnail cache files ._* Thumbs.db # Files that might appear on external disks .Spotlight-V100 .Trashes # Compiled Python files *.pyc # Compiled C++ files *.out # Application specific files venv node_modules .sass-cache MySQL安装我们将使用 Homebrew 安装 MySQL，同时也会安装 MySQL 的相关文件。 安装 MySQL: $ brew update # 这是一个好习惯 $ brew install mysql 在使用 MySQL 前，我们需要做一些设置： $ unset TMPDIR $ mkdir /usr/local/var $ mysql_install_db --verbose --user=`whoami` --basedir=&quot;$(brew --prefix mysql)&quot; --datadir=/usr/local/var/mysql --tmpdir=/tmp 使用启动 MySQL 服务，运行 mysql.server $ mysql.server start 关闭 MySQL，运行： $ mysql.server stop 你可以了解更多 mysql.server 的命令，运行： $ mysql.server --help 登录 MySQL, 运行: $ mysql -uroot Note: 默认情况下，MySQL 用户 root 没有密码，这对本地开发没有关系，但如果你希望修改密码，你可以运行: $ mysqladmin -u root password &#39;new-password&#39; 译注： 当你在设置密码时出现问题，可以参考 lgn21st 的方式。 此外，如果你觉得敲那么多命令是一件很麻烦的事情，那么你也可以参考 Mac OS安装 MySQL（使用二进制PGK包安装） Node.js使用 Homebrew 安装 Node.js: $ brew update $ brew install node 一般 Node modules 通常被安装在每个项目的本地文件夹 node_modules， 但有几个包推荐你安装在全局： CoffeeScript、 Less、 Grunt 或 Gulp $ npm install -g coffee-script $ npm install -g less $ npm install -g grunt-cli $ npm install -g gulp Npm 使用安装包: $ npm install &lt;package&gt; # 安装在本地项目中 $ npm install -g &lt;package&gt; # 安装在全局 安装包，并且将其保存你项目中的 package.json 文件: $ npm install &lt;package&gt; --save 查看 npm 安装的内容: $ npm list # 本地 $ npm list -g # 全局 查看过期的包（本地或全局）: $ npm outdated [-g] 更新全部或特别指定一个包: $ npm update [&lt;package&gt;] 卸载包: $ npm uninstall &lt;package&gt; Apps这里推荐的 apps 在开发者圈子内普遍评价不错，能便利的处理日常的开发和使用的任务。以下推荐分为四类： 开发者工具 生产力工具 办公工具 其他 Developer Tools Google Chrome Webstorm Sketch Dash Sequel Pro Parallels Github Productivity 1Password : 跨平台的密码管理工具 Alfred 2 : 搜索工具，强烈建议更新至 power pack，可以参考 借助 Alfred 2 的 Workflows 功能可以做哪些好玩的事情？ AppCleaner: 应用程序卸载工具 Dropbox: 文件同步工具 Reeder：RSS 阅读工具 Pocket : 稍后阅读工具 Spectacle : 让窗口成比例的显示，在写代码调试的时候很方便 Unarchiver: 支持多种格式（包括 windows下的格式）的压缩/解压缩工具 OminiFocus ：时间管理工具 Mou：Markdown 编辑器，国人出品 [Sip] 取色器 [MindeNode] 思维导图 [xScope] 测量工具 [Lantern] 科学上网 [OhMyStar] Github star 管理 Office Apps Keynote Numbers Pages Microsoft Office Others CheatSheet : 长按 command ，将能查看当前程序的快捷键 Tweetbot: 最好的 twitter 客户端，优雅，精致","categories":[{"name":"编程","slug":"编程","permalink":"http://blog.cuteximi.com/categories/编程/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://blog.cuteximi.com/tags/mac/"}]},{"title":"pip-bug解决方案","slug":"pip-bug解决方案","date":"2018-09-19T06:37:11.000Z","updated":"2018-09-19T06:40:21.295Z","comments":true,"path":"pip-bug解决方案/","link":"","permalink":"http://blog.cuteximi.com/pip-bug解决方案/","excerpt":"","text":"使用pip3 出现以下错误： (most recent call last):File “/usr/bin/pip3”, line 9, in from pip import main 或者pip升级时也出现这个问题这是pip 10.0.0版本的BUG 解决办法 修改 /usr/bin/pip 文件 from pip import main if __name__ == '__main__': sys.exit(main()) 改为： from pip import __main__ if __name__ == '__main__': sys.exit(__main__._main())","categories":[],"tags":[{"name":"pip","slug":"pip","permalink":"http://blog.cuteximi.com/tags/pip/"}]},{"title":"SpringBoot采坑|启动项目检测不到Controller","slug":"SpringBoot采坑-启动项目检测不到Controller","date":"2018-09-19T06:34:27.000Z","updated":"2018-09-19T06:40:18.087Z","comments":true,"path":"SpringBoot采坑-启动项目检测不到Controller/","link":"","permalink":"http://blog.cuteximi.com/SpringBoot采坑-启动项目检测不到Controller/","excerpt":"","text":"问题描述：springboot项目访问不到controller方法。 【分析】应该是springboot并没有扫描到controller。【查看日志】记录此时的日志输出 /Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/bin/java -XX:TieredStopAtLevel=1 -noverify -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=51893 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=127.0.0.1 -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=true &quot;-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=51894:/Applications/IntelliJ IDEA.app/Contents/bin&quot; -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/tools.jar:/Users/taoshilei/Documents/springbootdemo/target/classes:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter-jdbc/2.0.4.RELEASE/spring-boot-starter-jdbc-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter/2.0.4.RELEASE/spring-boot-starter-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot/2.0.4.RELEASE/spring-boot-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter-logging/2.0.4.RELEASE/spring-boot-starter-logging-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar:/Users/taoshilei/.m2/repository/ch/qos/logback/logback-core/1.2.3/logback-core-1.2.3.jar:/Users/taoshilei/.m2/repository/org/apache/logging/log4j/log4j-to-slf4j/2.10.0/log4j-to-slf4j-2.10.0.jar:/Users/taoshilei/.m2/repository/org/apache/logging/log4j/log4j-api/2.10.0/log4j-api-2.10.0.jar:/Users/taoshilei/.m2/repository/org/slf4j/jul-to-slf4j/1.7.25/jul-to-slf4j-1.7.25.jar:/Users/taoshilei/.m2/repository/javax/annotation/javax.annotation-api/1.3.2/javax.annotation-api-1.3.2.jar:/Users/taoshilei/.m2/repository/org/yaml/snakeyaml/1.19/snakeyaml-1.19.jar:/Users/taoshilei/.m2/repository/com/zaxxer/HikariCP/2.7.9/HikariCP-2.7.9.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-jdbc/5.0.8.RELEASE/spring-jdbc-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-beans/5.0.8.RELEASE/spring-beans-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-tx/5.0.8.RELEASE/spring-tx-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter-web/2.0.4.RELEASE/spring-boot-starter-web-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter-json/2.0.4.RELEASE/spring-boot-starter-json-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/datatype/jackson-datatype-jdk8/2.9.6/jackson-datatype-jdk8-2.9.6.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/datatype/jackson-datatype-jsr310/2.9.6/jackson-datatype-jsr310-2.9.6.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter-tomcat/2.0.4.RELEASE/spring-boot-starter-tomcat-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/org/apache/tomcat/embed/tomcat-embed-core/8.5.32/tomcat-embed-core-8.5.32.jar:/Users/taoshilei/.m2/repository/org/apache/tomcat/embed/tomcat-embed-el/8.5.32/tomcat-embed-el-8.5.32.jar:/Users/taoshilei/.m2/repository/org/apache/tomcat/embed/tomcat-embed-websocket/8.5.32/tomcat-embed-websocket-8.5.32.jar:/Users/taoshilei/.m2/repository/org/hibernate/validator/hibernate-validator/6.0.11.Final/hibernate-validator-6.0.11.Final.jar:/Users/taoshilei/.m2/repository/javax/validation/validation-api/2.0.1.Final/validation-api-2.0.1.Final.jar:/Users/taoshilei/.m2/repository/org/jboss/logging/jboss-logging/3.3.2.Final/jboss-logging-3.3.2.Final.jar:/Users/taoshilei/.m2/repository/com/fasterxml/classmate/1.3.4/classmate-1.3.4.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-web/5.0.8.RELEASE/spring-web-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-webmvc/5.0.8.RELEASE/spring-webmvc-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-aop/5.0.8.RELEASE/spring-aop-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-context/5.0.8.RELEASE/spring-context-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-expression/5.0.8.RELEASE/spring-expression-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/mybatis/spring/boot/mybatis-spring-boot-starter/1.3.1/mybatis-spring-boot-starter-1.3.1.jar:/Users/taoshilei/.m2/repository/org/mybatis/spring/boot/mybatis-spring-boot-autoconfigure/1.3.1/mybatis-spring-boot-autoconfigure-1.3.1.jar:/Users/taoshilei/.m2/repository/org/mybatis/mybatis/3.4.5/mybatis-3.4.5.jar:/Users/taoshilei/.m2/repository/org/mybatis/mybatis-spring/1.3.1/mybatis-spring-1.3.1.jar:/Users/taoshilei/.m2/repository/mysql/mysql-connector-java/5.1.46/mysql-connector-java-5.1.46.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-core/5.0.8.RELEASE/spring-core-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-jcl/5.0.8.RELEASE/spring-jcl-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/apache/commons/commons-lang3/3.4/commons-lang3-3.4.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/module/jackson-module-parameter-names/2.9.6/jackson-module-parameter-names-2.9.6.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/core/jackson-core/2.9.6/jackson-core-2.9.6.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.9.6/jackson-databind-2.9.6.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/core/jackson-annotations/2.9.0/jackson-annotations-2.9.0.jar:/Users/taoshilei/.m2/repository/com/github/pagehelper/pagehelper-spring-boot-starter/1.2.5/pagehelper-spring-boot-starter-1.2.5.jar:/Users/taoshilei/.m2/repository/com/github/pagehelper/pagehelper-spring-boot-autoconfigure/1.2.5/pagehelper-spring-boot-autoconfigure-1.2.5.jar:/Users/taoshilei/.m2/repository/com/github/pagehelper/pagehelper/5.1.4/pagehelper-5.1.4.jar:/Users/taoshilei/.m2/repository/com/github/jsqlparser/jsqlparser/1.0/jsqlparser-1.0.jar:/Users/taoshilei/.m2/repository/com/alibaba/druid-spring-boot-starter/1.1.9/druid-spring-boot-starter-1.1.9.jar:/Users/taoshilei/.m2/repository/com/alibaba/druid/1.1.9/druid-1.1.9.jar:/Users/taoshilei/.m2/repository/org/slf4j/slf4j-api/1.7.25/slf4j-api-1.7.25.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/2.0.4.RELEASE/spring-boot-autoconfigure-2.0.4.RELEASE.jar com.cuteximi.springbootdemo.SpringbootdemoApplication . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.4.RELEASE) 2018-08-26 17:14:42.416 INFO 2196 --- [ main] c.c.s.SpringbootdemoApplication : Starting SpringbootdemoApplication on ximi.local with PID 2196 (/Users/taoshilei/Documents/springbootdemo/target/classes started by taoshilei in /Users/taoshilei/Documents/springbootdemo) 2018-08-26 17:14:42.419 INFO 2196 --- [ main] c.c.s.SpringbootdemoApplication : No active profile set, falling back to default profiles: default 2018-08-26 17:14:42.481 INFO 2196 --- [ main] ConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@4f6ee6e4: startup date [Sun Aug 26 17:14:42 CST 2018]; root of context hierarchy 2018-08-26 17:14:43.641 INFO 2196 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2018-08-26 17:14:43.659 INFO 2196 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2018-08-26 17:14:43.659 INFO 2196 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.32 2018-08-26 17:14:43.662 INFO 2196 --- [ost-startStop-1] o.a.catalina.core.AprLifecycleListener : The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: [/Users/taoshilei/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.] 2018-08-26 17:14:43.717 INFO 2196 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2018-08-26 17:14:43.717 INFO 2196 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1239 ms 2018-08-26 17:14:43.779 INFO 2196 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Servlet dispatcherServlet mapped to [/] 2018-08-26 17:14:43.780 INFO 2196 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Servlet statViewServlet mapped to [/druid/*] 2018-08-26 17:14:43.782 INFO 2196 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &#39;characterEncodingFilter&#39; to: [/*] 2018-08-26 17:14:43.782 INFO 2196 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &#39;hiddenHttpMethodFilter&#39; to: [/*] 2018-08-26 17:14:43.782 INFO 2196 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &#39;httpPutFormContentFilter&#39; to: [/*] 2018-08-26 17:14:43.783 INFO 2196 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &#39;requestContextFilter&#39; to: [/*] 2018-08-26 17:14:43.783 INFO 2196 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &#39;webStatFilter&#39; to urls: [/*] 2018-08-26 17:14:43.823 INFO 2196 --- [ main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSource 2018-08-26 17:14:44.149 INFO 2196 --- [ main] com.alibaba.druid.pool.DruidDataSource : {dataSource-1} inited 2018-08-26 17:14:44.354 INFO 2196 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2018-08-26 17:14:44.474 INFO 2196 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@4f6ee6e4: startup date [Sun Aug 26 17:14:42 CST 2018]; root of context hierarchy 2018-08-26 17:14:44.511 INFO 2196 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error]}&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.error(javax.servlet.http.HttpServletRequest) 2018-08-26 17:14:44.512 INFO 2196 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error],produces=[text/html]}&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse) 2018-08-26 17:14:44.529 INFO 2196 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2018-08-26 17:14:44.529 INFO 2196 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2018-08-26 17:14:44.744 INFO 2196 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup 2018-08-26 17:14:44.745 INFO 2196 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Bean with name &#39;statFilter&#39; has been autodetected for JMX exposure 2018-08-26 17:14:44.746 INFO 2196 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Bean with name &#39;dataSource&#39; has been autodetected for JMX exposure 2018-08-26 17:14:44.749 INFO 2196 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Located MBean &#39;dataSource&#39;: registering with JMX server as MBean [com.alibaba.druid.spring.boot.autoconfigure:name=dataSource,type=DruidDataSourceWrapper] 2018-08-26 17:14:44.750 INFO 2196 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Located MBean &#39;statFilter&#39;: registering with JMX server as MBean [com.alibaba.druid.filter.stat:name=statFilter,type=StatFilter] 2018-08-26 17:14:44.789 INFO 2196 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &#39;&#39; 2018-08-26 17:14:44.793 INFO 2196 --- [ main] c.c.s.SpringbootdemoApplication : Started SpringbootdemoApplication in 2.774 seconds (JVM running for 3.516) 2018-08-26 17:15:29.784 INFO 2196 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring FrameworkServlet &#39;dispatcherServlet&#39; 2018-08-26 17:15:29.784 INFO 2196 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet &#39;dispatcherServlet&#39;: initialization started 2018-08-26 17:15:29.798 INFO 2196 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet &#39;dispatcherServlet&#39;: initialization completed in 14 ms 2018-08-26 17:17:08.584 INFO 2196 --- [ Thread-8] ConfigServletWebServerApplicationContext : Closing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@4f6ee6e4: startup date [Sun Aug 26 17:14:42 CST 2018]; root of context hierarchy 2018-08-26 17:17:08.599 INFO 2196 --- [ Thread-8] o.s.j.e.a.AnnotationMBeanExporter : Unregistering JMX-exposed beans on shutdown 2018-08-26 17:17:08.600 INFO 2196 --- [ Thread-8] o.s.j.e.a.AnnotationMBeanExporter : Unregistering JMX-exposed beans 2018-08-26 17:17:08.615 INFO 2196 --- [ Thread-8] com.alibaba.druid.pool.DruidDataSource : {dataSource-1} closed Process finished with exit code 130 (interrupted by signal 2: SIGINT) 【解决方案】试着使用网提供的思路，将启动类放到与controller文件夹同级。 【再次查看日志】 /Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/bin/java -XX:TieredStopAtLevel=1 -noverify -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=52845 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=127.0.0.1 -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=true &quot;-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=52846:/Applications/IntelliJ IDEA.app/Contents/bin&quot; -Dfile.encoding=UTF-8 -classpath /Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/tools.jar:/Users/taoshilei/Documents/springbootdemo/target/classes:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter-jdbc/2.0.4.RELEASE/spring-boot-starter-jdbc-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter/2.0.4.RELEASE/spring-boot-starter-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot/2.0.4.RELEASE/spring-boot-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter-logging/2.0.4.RELEASE/spring-boot-starter-logging-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar:/Users/taoshilei/.m2/repository/ch/qos/logback/logback-core/1.2.3/logback-core-1.2.3.jar:/Users/taoshilei/.m2/repository/org/apache/logging/log4j/log4j-to-slf4j/2.10.0/log4j-to-slf4j-2.10.0.jar:/Users/taoshilei/.m2/repository/org/apache/logging/log4j/log4j-api/2.10.0/log4j-api-2.10.0.jar:/Users/taoshilei/.m2/repository/org/slf4j/jul-to-slf4j/1.7.25/jul-to-slf4j-1.7.25.jar:/Users/taoshilei/.m2/repository/javax/annotation/javax.annotation-api/1.3.2/javax.annotation-api-1.3.2.jar:/Users/taoshilei/.m2/repository/org/yaml/snakeyaml/1.19/snakeyaml-1.19.jar:/Users/taoshilei/.m2/repository/com/zaxxer/HikariCP/2.7.9/HikariCP-2.7.9.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-jdbc/5.0.8.RELEASE/spring-jdbc-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-beans/5.0.8.RELEASE/spring-beans-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-tx/5.0.8.RELEASE/spring-tx-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter-web/2.0.4.RELEASE/spring-boot-starter-web-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter-json/2.0.4.RELEASE/spring-boot-starter-json-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/datatype/jackson-datatype-jdk8/2.9.6/jackson-datatype-jdk8-2.9.6.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/datatype/jackson-datatype-jsr310/2.9.6/jackson-datatype-jsr310-2.9.6.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-starter-tomcat/2.0.4.RELEASE/spring-boot-starter-tomcat-2.0.4.RELEASE.jar:/Users/taoshilei/.m2/repository/org/apache/tomcat/embed/tomcat-embed-core/8.5.32/tomcat-embed-core-8.5.32.jar:/Users/taoshilei/.m2/repository/org/apache/tomcat/embed/tomcat-embed-el/8.5.32/tomcat-embed-el-8.5.32.jar:/Users/taoshilei/.m2/repository/org/apache/tomcat/embed/tomcat-embed-websocket/8.5.32/tomcat-embed-websocket-8.5.32.jar:/Users/taoshilei/.m2/repository/org/hibernate/validator/hibernate-validator/6.0.11.Final/hibernate-validator-6.0.11.Final.jar:/Users/taoshilei/.m2/repository/javax/validation/validation-api/2.0.1.Final/validation-api-2.0.1.Final.jar:/Users/taoshilei/.m2/repository/org/jboss/logging/jboss-logging/3.3.2.Final/jboss-logging-3.3.2.Final.jar:/Users/taoshilei/.m2/repository/com/fasterxml/classmate/1.3.4/classmate-1.3.4.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-web/5.0.8.RELEASE/spring-web-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-webmvc/5.0.8.RELEASE/spring-webmvc-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-aop/5.0.8.RELEASE/spring-aop-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-context/5.0.8.RELEASE/spring-context-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-expression/5.0.8.RELEASE/spring-expression-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/mybatis/spring/boot/mybatis-spring-boot-starter/1.3.1/mybatis-spring-boot-starter-1.3.1.jar:/Users/taoshilei/.m2/repository/org/mybatis/spring/boot/mybatis-spring-boot-autoconfigure/1.3.1/mybatis-spring-boot-autoconfigure-1.3.1.jar:/Users/taoshilei/.m2/repository/org/mybatis/mybatis/3.4.5/mybatis-3.4.5.jar:/Users/taoshilei/.m2/repository/org/mybatis/mybatis-spring/1.3.1/mybatis-spring-1.3.1.jar:/Users/taoshilei/.m2/repository/mysql/mysql-connector-java/5.1.46/mysql-connector-java-5.1.46.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-core/5.0.8.RELEASE/spring-core-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/springframework/spring-jcl/5.0.8.RELEASE/spring-jcl-5.0.8.RELEASE.jar:/Users/taoshilei/.m2/repository/org/apache/commons/commons-lang3/3.4/commons-lang3-3.4.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/module/jackson-module-parameter-names/2.9.6/jackson-module-parameter-names-2.9.6.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/core/jackson-core/2.9.6/jackson-core-2.9.6.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.9.6/jackson-databind-2.9.6.jar:/Users/taoshilei/.m2/repository/com/fasterxml/jackson/core/jackson-annotations/2.9.0/jackson-annotations-2.9.0.jar:/Users/taoshilei/.m2/repository/com/github/pagehelper/pagehelper-spring-boot-starter/1.2.5/pagehelper-spring-boot-starter-1.2.5.jar:/Users/taoshilei/.m2/repository/com/github/pagehelper/pagehelper-spring-boot-autoconfigure/1.2.5/pagehelper-spring-boot-autoconfigure-1.2.5.jar:/Users/taoshilei/.m2/repository/com/github/pagehelper/pagehelper/5.1.4/pagehelper-5.1.4.jar:/Users/taoshilei/.m2/repository/com/github/jsqlparser/jsqlparser/1.0/jsqlparser-1.0.jar:/Users/taoshilei/.m2/repository/com/alibaba/druid-spring-boot-starter/1.1.9/druid-spring-boot-starter-1.1.9.jar:/Users/taoshilei/.m2/repository/com/alibaba/druid/1.1.9/druid-1.1.9.jar:/Users/taoshilei/.m2/repository/org/slf4j/slf4j-api/1.7.25/slf4j-api-1.7.25.jar:/Users/taoshilei/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/2.0.4.RELEASE/spring-boot-autoconfigure-2.0.4.RELEASE.jar com.cuteximi.springbootdemo.SpringbootdemoApplication . ____ _ __ _ _ /\\\\ / ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.4.RELEASE) 2018-08-26 17:50:40.248 INFO 2506 --- [ main] c.c.s.SpringbootdemoApplication : Starting SpringbootdemoApplication on ximi.local with PID 2506 (/Users/taoshilei/Documents/springbootdemo/target/classes started by taoshilei in /Users/taoshilei/Documents/springbootdemo) 2018-08-26 17:50:40.251 INFO 2506 --- [ main] c.c.s.SpringbootdemoApplication : No active profile set, falling back to default profiles: default 2018-08-26 17:50:40.347 INFO 2506 --- [ main] ConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@359f7cdf: startup date [Sun Aug 26 17:50:40 CST 2018]; root of context hierarchy 2018-08-26 17:50:41.652 INFO 2506 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2018-08-26 17:50:41.674 INFO 2506 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2018-08-26 17:50:41.674 INFO 2506 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.32 2018-08-26 17:50:41.677 INFO 2506 --- [ost-startStop-1] o.a.catalina.core.AprLifecycleListener : The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: [/Users/taoshilei/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.] 2018-08-26 17:50:41.739 INFO 2506 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2018-08-26 17:50:41.739 INFO 2506 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1395 ms 2018-08-26 17:50:41.814 INFO 2506 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Servlet dispatcherServlet mapped to [/] 2018-08-26 17:50:41.815 INFO 2506 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Servlet statViewServlet mapped to [/druid/*] 2018-08-26 17:50:41.817 INFO 2506 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &#39;characterEncodingFilter&#39; to: [/*] 2018-08-26 17:50:41.818 INFO 2506 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &#39;hiddenHttpMethodFilter&#39; to: [/*] 2018-08-26 17:50:41.818 INFO 2506 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &#39;httpPutFormContentFilter&#39; to: [/*] 2018-08-26 17:50:41.818 INFO 2506 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &#39;requestContextFilter&#39; to: [/*] 2018-08-26 17:50:41.818 INFO 2506 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &#39;webStatFilter&#39; to urls: [/*] 2018-08-26 17:50:41.862 INFO 2506 --- [ main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSource 2018-08-26 17:50:42.174 INFO 2506 --- [ main] com.alibaba.druid.pool.DruidDataSource : {dataSource-1} inited 2018-08-26 17:50:42.372 INFO 2506 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2018-08-26 17:50:42.493 INFO 2506 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@359f7cdf: startup date [Sun Aug 26 17:50:40 CST 2018]; root of context hierarchy 2018-08-26 17:50:42.524 INFO 2506 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/list],methods=[GET]}&quot; onto public java.util.List&lt;com.cuteximi.springbootdemo.domain.User&gt; com.cuteximi.springbootdemo.controller.StudentController.test1() 2018-08-26 17:50:42.528 INFO 2506 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error]}&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.error(javax.servlet.http.HttpServletRequest) 2018-08-26 17:50:42.528 INFO 2506 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error],produces=[text/html]}&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse) 2018-08-26 17:50:42.545 INFO 2506 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2018-08-26 17:50:42.545 INFO 2506 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler] 2018-08-26 17:50:42.717 INFO 2506 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup 2018-08-26 17:50:42.718 INFO 2506 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Bean with name &#39;statFilter&#39; has been autodetected for JMX exposure 2018-08-26 17:50:42.718 INFO 2506 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Bean with name &#39;dataSource&#39; has been autodetected for JMX exposure 2018-08-26 17:50:42.722 INFO 2506 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Located MBean &#39;dataSource&#39;: registering with JMX server as MBean [com.alibaba.druid.spring.boot.autoconfigure:name=dataSource,type=DruidDataSourceWrapper] 2018-08-26 17:50:42.723 INFO 2506 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Located MBean &#39;statFilter&#39;: registering with JMX server as MBean [com.alibaba.druid.filter.stat:name=statFilter,type=StatFilter] 2018-08-26 17:50:42.762 INFO 2506 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &#39;&#39; 2018-08-26 17:50:42.768 INFO 2506 --- [ main] c.c.s.SpringbootdemoApplication : Started SpringbootdemoApplication in 2.914 seconds (JVM running for 3.529) 对比两次日志，多了这一条： 2018-08-26 17:50:42.524 INFO 2506 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/list],methods=[GET]}&quot; onto public java.util.List&lt;com.cuteximi.springbootdemo.domain.User&gt; com.cuteximi.springbootdemo.controller.StudentController.test1() 实验结果：","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.cuteximi.com/tags/Spring-Boot/"}]},{"title":"致自己-关键总结","slug":"致自己-关键总结","date":"2018-09-19T06:30:09.000Z","updated":"2018-09-19T06:40:19.705Z","comments":true,"path":"致自己-关键总结/","link":"","permalink":"http://blog.cuteximi.com/致自己-关键总结/","excerpt":"","text":"Google was late to search.Facebook was late to social networking.Apple was late to the MP3 Player. It`s never to late.Just do it better. 任何时候做任何决定都不是最晚的时候，而是你要斟酌自己自身的实力，不要去企图把小概率事件扣到自己的头上。 借用stormzhang（帅张）一段话： 人的一生有很多重要的决定，最大的可能是在做正确的决定其实决定了你未来的人生，是否考研，是否转行，要不要去投资个生意，爱上一个女孩要不要去追等等等，做这些所有的选择与决定之前，想想自身的优势，结合趋势和风口，看一下自己做这件事的把握有多少，单反但凡重大决定，不要想着在尝试中去找答案，对于小事情这样是可以的，但是对于一些重要决定是没有尝试的机会的，想尽一切办法想把仗打赢的，是最难的，你该做的，是在一开始选择前，这场仗能打赢，再去打。 最后（还是引用stormzhang）一句话告诫自己：永远不要以小概率事件来决策，永远不要把自己当成小概率事件的缔造者。","categories":[],"tags":[]},{"title":"致自己","slug":"致自己","date":"2018-09-19T06:30:03.000Z","updated":"2018-09-19T06:40:22.501Z","comments":true,"path":"致自己/","link":"","permalink":"http://blog.cuteximi.com/致自己/","excerpt":"","text":"Google was late to search.Facebook was late to social networking.Apple was late to the MP3 Player. It`s never to late.Just do it better. 任何时候做任何决定都不是最晚的时候，而是你要斟酌自己自身的实力，不要去企图把小概率事件扣到自己的头上。 借用stormzhang（帅张）一段话： 人的一生有很多重要的决定，最大的可能是在做正确的决定其实决定了你未来的人生，是否考研，是否转行，要不要去投资个生意，爱上一个女孩要不要去追等等等，做这些所有的选择与决定之前，想想自身的优势，结合趋势和风口，看一下自己做这件事的把握有多少，单反但凡重大决定，不要想着在尝试中去找答案，对于小事情这样是可以的，但是对于一些重要决定是没有尝试的机会的，想尽一切办法想把仗打赢的，是最难的，你该做的，是在一开始选择前，这场仗能打赢，再去打。 最后（还是引用stormzhang）一句话告诫自己：永远不要以小概率事件来决策，永远不要把自己当成小概率事件的缔造者。","categories":[{"name":"致自己","slug":"致自己","permalink":"http://blog.cuteximi.com/categories/致自己/"}],"tags":[]},{"title":"jstat使用指南","slug":"jstat使用指南","date":"2018-09-19T06:23:46.000Z","updated":"2018-09-19T06:27:49.963Z","comments":true,"path":"jstat使用指南/","link":"","permalink":"http://blog.cuteximi.com/jstat使用指南/","excerpt":"","text":"jstat命令使用1 说在前面 提示：可以通过jps查看虚拟机进程的id例如：使用命令jps -l注意：本次演示使用的jdk版本是jdk8. 2 jstat简介jstat命令可以监控Java堆状况，监控类装载、卸载数量等，监控JIT编译等。命令的格式如下： [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]3 演示各个参数3.1 类加载统计 命令行输入：jstat -class 70815 Loaded Bytes Unloaded Bytes Time 3610 6339.0 0 0.0 4.01 说明 Loaded:加载class的数量 Bytes：所占用空间大小 Unloaded：未加载数量 Bytes:未加载占用空间 Time：时间 3.2 编译统计 命令行输入：jstat -compiler 70815 Compiled Failed Invalid Time FailedType FailedMethod 1624 0 0 2.08 0 说明 Compiled：编译数量。 Failed：失败数量 Invalid：不可用数量 Time：时间 FailedType：失败类型 FailedMethod：失败的方法 3.3 垃圾回收统计命令行输入：jstat -gc 70815可右划查看结果。 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT 5120.0 5120.0 5100.9 0.0 33280.0 2452.0 87552.0 4345.6 18560.0 18133.4 2432.0 2216.3 4 0.033 1 0.014 0.047 说明 S0C：第一个幸存区的大小 S1C：第二个幸存区的大小 S0U：第一个幸存区的使用大小 S1U：第二个幸存区的使用大小 EC：新生代的大小 EU：新生代的使用大小 OC：老年代大小 OU：老年代使用大小 MC：方法区大小 MU：方法区使用大小 CCSC:压缩类空间大小 CCSU:压缩类空间使用大小 YGC：年轻代垃圾回收次数 YGCT：年轻代垃圾回收消耗时间 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间 3.4 堆内存统计输入命令：jstat -gcapacity 70815 NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC 43520.0 262144.0 43520.0 5120.0 5120.0 33280.0 87552.0 524288.0 87552.0 87552.0 0.0 1064960.0 18560.0 0.0 1048576.0 2432.0 4 1 说明 NGCMN：新生代最小容量 NGCMX：新生代最大容量 NGC：当前新生代容量 S0C：第一个幸存区大小 S1C：第二个幸存区的大小 EC：Eden区的大小 OGCMN：老年代最小容量 OGCMX：老年代最大容量 OGC：当前老年代大小 OC: 当前老年代大小 MCMN: 最小元数据容量 MCMX：最大元数据容量 MC：当前元数据空间大小 CCSMN：最小压缩类空间大小 CCSMX：最大压缩类空间大小 CCSC：当前压缩类空间大小 YGC：年轻代gc次数 FGC：老年代GC次数 3.5 新生代垃圾回收统计输入命令：jstat -gcnew 70815 S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT 5120.0 5120.0 5100.9 0.0 7 15 5120.0 33280.0 3198.8 4 0.033 说明 S0C：第一个幸存区大小 S1C：第二个幸存区的大小 S0U：第一个幸存区的使用大小 S1U：第二个幸存区的使用大小 TT:对象在新生代存活的次数 MTT:对象在新生代存活的最大次数 DSS:期望的幸存区大小 EC：Eden区的大小 EU：Eden区的使用大小 YGC：年轻代垃圾回收次数 YGCT：年轻代垃圾回收消耗时间 3.6 新生代内存统计输入命令：jstat -gcnewcapacity 70815 NGCMN NGCMX NGC S0CMX S0C S1CMX S1C ECMX EC YGC FGC 43520.0 262144.0 43520.0 87040.0 5120.0 87040.0 5120.0 261120.0 33280.0 4 1 说明 NGCMN：新生代最小容量 NGCMX：新生代最大容量 NGC：当前新生代容量 S0CMX：最大幸存1区大小 S0C：当前幸存1区大小 S1CMX：最大幸存2区大小 S1C：当前幸存2区大小 ECMX：最大Eden区大小 EC：当前Eden区大小 YGC：年轻代垃圾回收次数 FGC：老年代回收次数 3.7 老年代垃圾回收统计输入命令： jstat -gcold 70815 MC MU CCSC CCSU OC OU YGC FGC FGCT GCT 18560.0 18133.4 2432.0 2216.3 87552.0 4345.6 4 1 0.014 0.047 说明 MC：方法区大小 MU：方法区使用大小 CCSC:压缩类空间大小 CCSU:压缩类空间使用大小 OC：老年代大小 OU：老年代使用大小 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间 3.8 老年代内存统计输入命令：jstat -gcoldcapacity 70815 OGCMN OGCMX OGC OC YGC FGC FGCT GCT 87552.0 524288.0 87552.0 87552.0 4 1 0.014 0.047 说明 OGCMN：老年代最小容量 OGCMX：老年代最大容量 OGC：当前老年代大小 OC：老年代大小 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间 3.9 元数据空间统计输入命令：jstat -gcmetacapacity 70815 MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC FGCT GCT 0.0 1064960.0 18560.0 0.0 1048576.0 2432.0 4 1 0.014 0.047 说明 MCMN:最小元数据容量 MCMX：最大元数据容量 MC：当前元数据空间大小 CCSMN：最小压缩类空间大小 CCSMX：最大压缩类空间大小 CCSC：当前压缩类空间大小 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间 总结垃圾回收统计输入命令：jstat -gcutil 70815 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 99.63 0.00 11.95 4.96 97.70 91.13 4 0.033 1 0.014 0.047 说明 S0：幸存1区当前使用比例 S1：幸存2区当前使用比例 E：Eden区使用比例 O：老年代使用比例 M：元数据区使用比例 CCS：压缩使用比例 YGC：年轻代垃圾回收次数 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间 3.10 JVM编译方法统计输入命令：jstat printcompliation 70815 Compiled Size Type Method 1708 8 1 java/lang/reflect/WeakCache$LookupValue hashCode 说明 Compiled：最近编译方法的数量 Size：最近编译方法的字节码数量 Type：最近编译方法的编译类型。 Method：方法名标识。 说在最后Google was late to search.Facebook was late to social networking.Apple was late to the MP3 Player.It`s never to late.Just do it better. 任何时候做任何决定都不是最晚的时候，而是你要斟酌自己自身的实力，不要去企图把小概率事件扣到自己的头上。 借用stormzhang（帅张）一段话： 人的一生有很多重要的决定，最大的可能是在做正确的决定其实决定了你未来的人生，是否考研，是否抓航，要不要去投资个生意，爱上一个女孩要不要去追等等等，做这些所有的选择与决定之前，想想自身的优势，结合趋势和风口，看一下自己做这件事的把握有多少，单反但凡重大决定，不要想着在尝试中去找答案，对于小事情这样是可以的，但是对于一些重要决定是没有尝试的机会的，想尽一切办法想把仗打赢的，是最难的，你该做的，是在一开始选择前，这场仗能打赢，再去打。 最后（还是引用stormzhang）一句话告诫自己：永远不要以小概率事件来决策，永远不要把自己当成小概率事件的缔造者。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://blog.cuteximi.com/categories/JVM/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.cuteximi.com/tags/工具/"}]},{"title":"一个牛逼的coder","slug":"一个牛逼的coder","date":"2018-09-18T12:08:47.000Z","updated":"2018-09-18T12:15:22.681Z","comments":true,"path":"一个牛逼的coder/","link":"","permalink":"http://blog.cuteximi.com/一个牛逼的coder/","excerpt":"","text":"大厂offer拿到手软，同样毕业，为什么别人可以拿到很多大厂的offer？大 厂更看重毕业生哪一点？ 阅读文本大概需要 4 分钟。 今天我给大家分享一个帖子： 一个有实力的coder应该要知道的领域 基础知识 1.算法和数据结构 数据，链表，二叉树，队列，栈的各种操作（性能，场景） 二分查找和各种变种的二分查找 各类排序算法以及时间复杂度分析 各类算法题（手写） 理解并可以分子时间和空间复杂度 动态规划 红黑树/AVL树，Hash树，Tire树，B树，B+树 图算法 2.计算机网络 OSI七层协议（TCP四层） 每一层的协议 URL到页面的过程 HTTPhttp/https 1.0 1.1 2.0 get/post以及幂等性 http协议头相关网络攻击（CSRF,XSS） TCP/IP三次握手，四次挥手拥塞控制（过程/阈值） 流量控制与滑动窗口 TCP和UDP的比较子网划分（笔试） DDOS攻击 IO/NIO/AIO三者原理，各个语言是怎么实现的； Netty Linux内核select poll epoll 3.数据库 索引（分类以及优化方式，失效条件，底层结构）； sql语法； 引擎对比； 数据库的锁（行锁，表锁，页级索，意向锁，读锁，写锁，悲观锁，乐观锁，以及枷锁的select sql方式）； 隔离界别，依次解决的问题（脏读，不可重复读，幻读）； 事物的ACID； B树，B+树优化（explain,慢查询，show profile）； 数据库的范式分库分表，主从复制，读写分离； Nosql相关（redis和mencached区别）； redis相关； 4.操作系统 进程通信IPC（几种方式），与线程的区别； OS的几种策略（页面置换，进程调度，每个里面算法）； 互斥与死锁相关的； Linux常用命令； Linux内核相关； 5.编程语言(java) java基础、集合、并发； 多线程（线程池，SYNC和Lock锁机制，线程通信，volatile、ThreadLocal,Cyclibarrier,Atom包，CountDownLatch,AQS,CAS原理）； JVM（内存模型，gc垃圾回收，包括分代，GC算法，收集器，类加载和双亲委派机制，内存泄漏和内存溢出）； IO/NIO相关、反射和代理，异常； java8相关的； 序列化、设计模式（常用的）； web相关的（servlet, cookie/session, Spring(AOP,IOC,MVC事务，动态代理）； mybatis.Tomcat,Hibernate等看源码； 6.分布式架构 （了解原理就行，如果真的有实践经验更好） CAP原理和BASE理论。 Nosql与KV存储（redis，hbase，mongodb，memcached等） 服务化理论（包括服务发现、治理等，zookeeper、etcd、springcloud微服务、） 负载均衡（原理、cdn、一致性hash） RPC框架（包括整体的一些框架理论，通信的netty，序列化协议thrift，protobuff等） 消息队列（原理、kafka，activeMQ，rocketMQ） 分布式存储系统（GFS、HDFS、fastDFS）、存储模型（skipList、LSM等） 分布式事务、分布式锁等 7.脚本语言 （只是作为横向扩充，一般问到linux也会问问shell脚本） python ， php ，shell ，golang 。 8.大数据与数据分析 hadoop生态圈(hive、hbase、hdfs、zookeeper、storm、kafka) spark体系 ，语言：python、R、scala 搜索引擎与技术 9.机器学习算法 模型和算法很多。不细说了，如果很熟练就去投算法，国内很多公司都算法岗都很稀缺，其他岗可以大概了解下理论。 10.其他工具的理论和使用 这个更多了，问的多的比如git、docker、maven/gradle、Jenkins等等，自己需要的话选择性地去学。 说了这么多…推荐几本良心的书籍吧。 推荐书单 算法与数据结构： 数据结构（严蔚敏）/大话数据结构 剑指Offer/程序员面试金典/编程珠玑/编程之美/牛客网+leetcode 程序员笔试面试最优解（左程云） Java的版本（不是很推荐）： 数据结构与算法经典问题解析（Java语言描述） 图解数据结构（使用Java） 计算机网络： 计算机网络（谢希仁） TCP/IP 详解 HTTP权威指南 图解TCP/IP 图解HTTP 数据库： 数据库主要是多用，书上主要看索引和性能的部分 高性能MySQL/深入浅出MySQL 操作系统： OS原理：操作系统（课本，黑色的那个） Linux： Linux私房菜 //鸟哥写的，很全，包括bash部分 跟阿铭学Linux //主要偏重于命令和操作，比较浅显 Java： Java疯狂讲义/Java编程思想/Java核心技术 卷1 深入理解Java虚拟机 并发编程的艺术/多线程编程核心技术 Effective Java Java程序员面试笔试宝典 //何昊的那本，个人感觉是突击知识点的神器 Java程序性能优化 实战Java高并发程序设计 Java Web： Spring实战/轻量级JavaEE 企业应用（红皮，讲SSH的） //主要看最后一部分Spring的就可以 深入JavaWeb技术内幕（阿里 许令波）//这个讲的还是比较深的 SpringBoot实战/深入实践SpringBoot 设计模式： 大话设计模式 //通俗易懂 各类博客的总结 分布式与大数据： 分布式服务框架原理与实践 大型网站技术架构 Hadoop实战（hadoop体系包括得很全） 其他： Git： Git权威指南 Git官方讲解视频（牛客网有带字幕的） Redis： Redis实战 是不是觉得有点多啊？当然，大佬都是一步一步积累的，加油吧！优秀的你，肯定有时间，有耐心，有毅力！ 本文编辑：cuteximi 参考：网友分享 &amp; 整理 版式：cuteximi End - - - - 如果觉得对你有帮助，请持续关注转发，谢谢各位。 cuteximi.com","categories":[{"name":"程序员","slug":"程序员","permalink":"http://blog.cuteximi.com/categories/程序员/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"http://blog.cuteximi.com/tags/程序员/"}]},{"title":"network-generator","slug":"network-generator","date":"2018-04-08T00:45:51.000Z","updated":"2018-04-08T00:52:38.000Z","comments":true,"path":"network-generator/","link":"","permalink":"http://blog.cuteximi.com/network-generator/","excerpt":"","text":"一、概述 网络的网络 ISP 主机之间的通信方式 电路交换与分组交换 时延 计算机网络体系结构* 二、物理层 通信方式 带通调制 信道复用技术 三、数据链路层 信道分类 三个基本问题 局域网 PPP 协议 CSMA/CD 协议* 扩展局域网* MAC 层* 四、网络层* 网际协议 IP 概述 IP 数据报格式 IP 地址编址方式 IP 地址和 MAC 地址 地址解析协议 ARP 路由器的结构 路由器分组转发流程 路由选择协议 网际控制报文协议 ICMP 分组网间探测 PING 虚拟专用网 VPN 网络地址转换 NAT 五、运输层* UDP 和 TCP 的特点 UDP 首部格式 TCP 首部格式 TCP 的三次握手 TCP 的四次挥手 TCP 滑动窗口 TCP 可靠传输 TCP 流量控制 TCP 拥塞控制 六、应用层* 域名系统 DNS 文件传输协议 FTP 远程终端协议 TELNET 电子邮件协议 动态主机配置协议 DHCP 点对点传输 P2P Web 页面请求过程 常用端口 参考资料 一、概述网络的网络网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。 ISP互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为主干 ISP、地区 ISP 和本地 ISP。 互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。 主机之间的通信方式 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 对等（P2P）：不区分客户和服务器。 电路交换与分组交换 （以上分别为：电路交换、报文交换以及分组交换） 1. 电路交换电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 2. 报文交换报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。 3. 分组交换分组交换也使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了目的地址和源地址等控制信息。 存储转发允许在一条传输线路上传送多个主机的分组，也就是说两个用户之间的通信不需要占用端到端的线路资源。 相比于报文交换，由于分组比报文更小，因此分组交换的存储转发速度更加快速。 时延总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 1. 发送时延主机或路由器发送数据帧所需要的时间。 其中 l 表示数据帧的长度，v 表示发送速率。 2. 传播时延电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。 其中 l 表示信道长度，v 表示电磁波在信道上的传播速率。 3. 处理时延主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据部、进行差错检验或查找适当的路由等。 4. 排队时延分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 计算机网络体系结构* 1. 七层协议如图 a 所示，其中表示层和会话层用途如下： 表示层：信息的语法、语义以及它们的关联，如加密解密、转换翻译、压缩解压缩； 会话层：不同机器上的用户之间建立及管理会话。 2. 五层协议 应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层：为主机之间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的结点提供服务。数据链路层把网络层传来的分组封装成帧。 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 3. 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。 4. TCP/IP 体系结构它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。 二、物理层通信方式 单向通信，又称为单工通信； 双向交替通信，又称为半双工通信； 双向同时通信，又称为全双工通信。 带通调制模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。 信道复用技术1. 频分复用、时分复用频分复用的所有用户在相同的时间占用不同的频率带宽资源；时分复用的所有用户在不同的时间占用相同的频率带宽资源。 使用这两种方式进行通信，在通信的过程中用户会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。 2. 统计时分复用是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 3. 波分复用光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 4. 码分复用为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 和 有 为了讨论方便，取 m=8，设码片 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。 在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到 其中 为 的反码。 利用上面的式子我们知道，当接收端使用码片 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。 码分复用需要发送的数据量为原先的 m 倍。 三、数据链路层信道分类 点对点信道：一对一通信方式； 广播信道：一对多通信方式。 三个基本问题1. 封装成帧将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 2. 透明传输透明表示一个实际存在的事物看起来好像不存在一样。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符，如果出现转义字符，那么就在转义字符前面再加个转义字符，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 3. 差错检测目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 局域网局域网是典型的一种广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 可以按照网络拓扑对局域网进行分类： PPP 协议用于点对点信道中。互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 在 PPP 的帧中： F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 CSMA/CD 协议*用于广播信道中。在广播信道上，同一时间只能允许一台计算机发送数据。 CSMA/CD 表示载波监听多点接入 / 碰撞检测。 多点接入 ：说明这是总线型网络，许多计算机以多点的方式连接到总线上。 载波监听 ：每个站都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听到信道已有其它站正在发送数据，就表示发生了碰撞。虽然每一个站在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定，从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 扩展局域网*1. 在物理层进行扩展使用集线器进行扩展。 集线器的主要功能是对接收到的信号进行放大，以扩大网络的传输距离。 集线器不能根据 MAC 地址进行转发，而是以广播的方式发送数据帧。 集线器是一种共享式的传输设备，意味着同一时刻只能传输一组数据帧。 2. 在链路层进行扩展最开始使用的是网桥，它收到一个帧时，根据帧的 MAC 地址，查找网桥中的地址表，确定帧转发的接口。 网桥不是共享式设备，因此性能比集线器这种共享式设备更高。 交换机的问世很快就淘汰了网桥，它实质上是一个多接口网桥，而网桥是两接口。交换机的每个接口都能直接与一个主机或者另一个交换机相连，并且一般都工作在全双工方式。 交换机具有自学习能力，学习的是交换表的内容。交换表中存储着 MAC 地址到接口的映射。下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧。主机 B 收下之后，查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 3 的映射。 3. 虚拟局域网虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息，例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。 MAC 层*MAC 地址是 6 字节（48 位）的地址，用于唯一标识网络适配器（网卡），一台主机拥有多少个适配器就有多少个 MAC 地址，例如笔记本电脑普遍存在无线网络适配器和有线网络适配器。 在 MAC 帧中： 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法； 前同步码 ：只是为了计算 FCS 临时加入的，计算结束之后会丢弃。 四、网络层*网际协议 IP 概述因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 IP 地址编址方式IP 地址的编址方式经历了三个历史阶段： 分类 子网划分 无分类 1. 分类由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。注意，外部网络看不到子网的存在。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 3. 无分类无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 IP 地址和 MAC 地址网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 地址解析协议 ARP实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。 路由器的结构路由器从功能上可以划分为：路由选择和分组转发。 分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 路由器分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 路由选择协议互联网使用的路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。 互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。 可以把路由选择协议划分为两大类： 内部网关协议 IGP（Interior Gateway Protocol）：在 AS 内部使用，如 RIP 和 OSPF。 外部网关协议 EGP（External Gateway Protocol）：在 AS 之间使用，如 BGP。 1. 内部网关协议 RIPRIP 是一种分布式的基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1，跳数最多为 15，超过 15 表示不可达。 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 RIP 协议实现简单，开销小，但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 2. 内部网关协议 OSPF开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 只有当链路状态发生变化时，路由器才会发送信息。 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 3. 外部网关协议 BGPAS 之间的路由选择很困难，主要是互联网规模很大。并且各个 AS 内部使用不同的路由选择协议，就无法准确定义路径的度量。并且 AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。它采用路径向量路由选择协议。 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 网际控制报文协议 ICMPICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 分组网间探测 PINGPING 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 Ping 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报。 Ping 的过程： 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，但 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指“好像是”，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 网络地址转换 NAT专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 五、运输层*网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。 UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）。 UDP 首部格式 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文段，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 要不再需要连接时，发送连接释放请求报文段，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2MSL 时间后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文段。 TCP 滑动窗口 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 1. 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。 2. 快重传与快恢复在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以确认下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。 在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 六、应用层*域名系统 DNS把主机名解析为 IP 地址。 被设计成分布式系统。 1. 层次结构一个域名由多个层次构成，从上层到下层分别为顶级域名、二级域名、三级域名以及四级域名。所有域名可以画成一颗域名树。 域名服务器可以分为以下四类： 根域名服务器：解析顶级域名； 顶级域名服务器：解析二级域名； 权限域名服务器：解析区内的域名； 本地域名服务器：也称为默认域名服务器。可以在其中配置高速缓存。 区和域的概念不同，可以在一个域中划分多个区。图 b 在域 abc.com 中划分了两个区：abc.com 和 y.abc.com 因此就需要两个权限域名服务器： 2. 解析过程主机向本地域名服务器解析的过程采用递归，而本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式。 迭代的方式下，本地域名服务器向一个域名服务器解析请求解析之后，结果返回到本地域名服务器，然后本地域名服务器继续向其它域名服务器请求解析；而递归的方式下，结果不是直接返回的，而是继续向前请求解析，最后的结果才会返回。 3. 使用的运输层协议DNS 在解析的过程使用 UDP 进行传输，因为 UDP 最大只支持 512 字节的数据，如果超过的话就需要使用 TCP 传输。 文件传输协议 FTPFTP 在运输层使用 TCP，并且需要建立两个并行的 TCP 连接：控制连接和数据连接。控制连接在整个会话期间一直保持打开，而数据连接在数据传送完毕之后就关闭。控制连接使用端口号 21，数据连接使用端口号 20。 远程终端协议 TELNETTELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 1. POP3POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。 2. IMAPIMAP 协议中客户端和服务器上的邮件保持同步，如果不去手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。IMAP 协议也支持创建自定义的文件夹。 3. SMTPSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主题的结构，定义了非 ASCII 码的编码规则。 动态主机配置协议 DHCPDHCP 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、默认路由器 IP 地址、域名服务器的 IP 地址。 工作方式如下：需要 IP 地址的主机广播发送 DHCP 发现报文（将目的地址置为全 1，即 255.255.255.255:67，源地址设置为全 0，即 0.0.0.0:68），DHCP 服务器收到发现报文之后，则在 IP 地址池中取一个地址，发送 DHCP 提供报文给该主机。 点对点传输 P2P把某个文件分发的所有对等集合称为一个洪流。文件的数据单元称为文件块，它的大小是固定的。一个新的对等方加入某个洪流，一开始并没有文件块，但是能够从其它对等方中逐渐地下载到一些文件块，与此同时，它也为别的对等方上传一些文件块。 每个洪流都有一个基础设施，称为追踪器。当一个对等方加入洪流时，必须向追踪器登记，并周期性地通知追踪器它仍在洪流中。可以在任何时间加入和退出某个洪流。 一个新的对等方加入洪流时，追踪器会随机从洪流中选择若干个对等方，并让新对等方与这些对等方建立连接，把这些对等方称为相邻对等方。接收和发送文件块都是在相邻对等方中进行。 当一个对等方需要很多文件块时，通过使用最稀有优先的策略来取得文件块，也就是一个文件块在相邻对等方中副本最少，那么就优先请求这个文件块。 当很多对等方向同一个对等方请求文件块时，该对等方优先选择以最高速率向其发送文件块的对等方。 P2P 是一个分布式系统，任何时候都有对等方加入或者退出。使用分布式散列表 DHT，可以查找洪流中的资源和 IP 地址映射。 Web 页面请求过程1. DHCP 配置主机信息 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 2. ARP 解析 MAC 地址 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 3. DNS 解析域名 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 4. HTTP 请求页面 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 HTTP 服务器收到该报文段之后，生成 TCP SYNACK 报文段，发回给主机。 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 常用端口 应用 应用层协议 端口号 运输层协议 备注 域名解析 DNS 53 UDP/TCP 长度超过 512 字节时使用 TCP 动态主机配置协议 DHCP 67/68 UDP 简单网络管理协议 SNMP 161/162 UDP 文件传送协议 FTP 20/21 TCP 控制连接 21，数据连接 20 远程终端协议 TELNET 23 TCP 超文本传送协议 HTTP 80 TCP 简单邮件传送协议 SMTP 25 TCP 邮件读取协议 POP3 110 TCP 网际报文存取协议 IMAP 143 TCP 参考资料 计算机网络, 谢希仁 JamesF.Kurose, KeithW.Ross, 库罗斯, 等. 计算机网络: 自顶向下方法 [M]. 机械工业出版社, 2014. Tackling emissions targets in Tokyo What does my ISP know when I use Tor? Technology-Computer Networking[1]-Computer Networks and the Internet P2P 网络概述. Circuit Switching (a) Circuit switching. (b) Packet switching.","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://blog.cuteximi.com/categories/计算机基础/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.cuteximi.com/tags/计算机网络/"}]},{"title":"Oracle-study","slug":"oracle-study","date":"2018-03-29T01:58:14.000Z","updated":"2018-03-29T02:11:15.000Z","comments":true,"path":"oracle-study/","link":"","permalink":"http://blog.cuteximi.com/oracle-study/","excerpt":"","text":"Oracle相关记录（by 陶世磊）2018-03-21 参考网络资源整理 简介Oracle Server 是由实例（instance）和数据库（database）组成。实例（instance）是由共享内存（SGA）和后台进程组成。数据库（dababase）是存储在磁盘的一系列文件。 详述SGASGA主要由Share Pool（共享池，又分Library Cache和Data Dictionary Cache，前者临时存储最近执行过的语句代码等，后者临时存储数据位置、表定义及用户权限等）、 数据缓冲区Database Buffer Cache（数据缓冲区，临时存储读过的数据块）、Redo Log Buffer（重做日志缓冲区，临时存储数据库修改操作）、Large Pool（大池，分担Share Pool部分工作供共享服务器进程使用，如备份恢复、大型I/O操作、并行查询等）和Java Pool（Java池，分析Java语句）。 后台进程后台进程是数据库和操作系统进行交互的通道，后台进程的命名由ORACLE_SID决定，ORACLE根据ORACLE_SID来寻找参数文件启动实例。是Oracle数据库为保持最佳性能和协调多用户请求而设置的，主要有DBWR（将Database Buffer Cache数据写入Data Files）、LGWR（将Redo Log Buffer数据写入Redo Log Files）CKPT（协调数据文件、控制文件和重做日志，将System Change Number即SCN写入到控制文件和数据文件头部，促使DBWR、LGWR执行）、SMON（System Monitor，3方面作用：instance recovery实例故障数据恢复、合并空闲碎片空间、回收临时段）、PMON（用户例程意外终止时处理事务，如回退事务、释放锁及其他资源等）、ARCH（将Redo Log Files写入Archive Log Files）、CJQ0（job queue coordinator）、RVWR（recover writer，为flashback database提供日志记录）等进程。 数据库数据库（database）是指存储在磁盘上的一组物理文件，如数据文件（Data files，用于存储数据）、控制文件（Control files，存储数据文件、重做日志文件、归档日志文件位置及维护数据库完整性所需信息）和重做日志文件（Redo Log files，存储修改数据的所有操作记录以备故障后恢复），这三个是启动数据库必须的文件；另外还有参数文件（Parameter file，设置内存后台进程的启动等）、归档日志文件（Archived Log files，归档记录写满的重做日志文件的内容）和口令文件（Password file，验证用户名密码），这三个是非必须的文件。 数据库启动三种状态数据库启动的三种方式（三个阶段）： nomount : 需要参数文件 mount ： 需要控制文件 open：需要全部的数据文件和日志文件，并且保证所有的数据文件和日志文件与控制文件里面记录的位置保持一致。 一般的启动顺序是：nomount–&gt;mount–&gt;open 启动详解① nomountnomount状态：启动实例。Reading the initialization file from $ORACLE_HOME/dbs in the following order: 从环境变量下dbs目录按如下顺序读取初始化文件： -first spfileSID.ora 首先，读取spfile+实例名.ora -if not found then, spfile.ora 若未发现文件则读取spfile.ora -if not found then, initSID.ora 若未发现文件则读取init+实例名.ora Specifying the PFILE parameter with STARTUP overrides the default behavior. 指定pfile参数文件启动以替代默认启动方式 Allocating the SGA 分配SGA Starting the background processes 启动后台进程 Opening the alertSID.log file and the trace files 启动预警日志文件（记录实例生命周期内事件，如系统内部错误、数据块损坏、系统参数修改等）和追踪文件（记录SQL操作及时间消耗等） The database must be named with the DB_NAME parameter either in the initialization Parameter file or in the STARTUP command. 数据库必须用初始参数文件或启动命令中的DB_NAME参数命名。 ② mountmount状态：关联实例与数据库，读取控制文件并获取数据文件和重做日志文件名称状态。 Mounting a database includes the following tasks: 装载数据库包括以下任务： Associating a database with a previously started instance 将先前启动的实例与数据库相关联 Locating and opening the control files specified in the parameter file 从参数文件中找到控制文件位置并打开 Reading the control files to obtain the names and status of the data files and online redo log files.However,no checks are performed to verify the existence of the data files and online redo log files at this time. 从控制文件中读取数据文件及重做日志文件名称与状态，但是，此时并不检查数据文件与重做日志文件的存在性。 ③ openopen状态： opening the database includes the following tasks: 打开数据库包含以下任务： opening the online data log files 打开数据文件 opening the onling redo log files 打开重做日志文件 If any of the datafiles or noline redo log files are not present when you attempt to open the database ,the oracle server returns an error. 若在打开数据库时数据文件或重做日志文件任何一个不存在，则Oracle服务器返回一个错误。 During this final stage,the oracle server verfies that all the data files and online redo log files can be opened and checks the consistency of the database. If necessary,the SMON background process initiates instance recovery. 在最后阶段，Oracle数据库验证数据文件和重做日志文件可否打开并检验数据库的一致性，若不一致，SMON后台进程将启动实例恢复。 shutdown或startup状态可执行的操作：shutdown相关shutdown有四个参数：normal、transactional、immediate、abort，不带参数默认为normal。 shutdown normal：不断开现在连接用户，阻止任何用户建立新的连接，包括管理员在内。已经连接的用户能够继续他们当前的工作，如递交新的更新事务，直到此用户自行断开连接。这样需要等待的时间长，可以查出现连用户，再通知其自行断开。所有的用户都断开连接，数据库才进行关闭操作，即关闭数据库、卸载数据库、终止例程。在这种情况下关闭的数据库在重新启动后，不会出现问题。启动时不需要实例恢复。 shutdown transactional：阻止任何用户建立新连接，等待所有当前连接用户的未递交的活动事务提交完毕，然后立即断开用户的连接。所有的用户都断开连接则立即关闭数据库，进行关闭数据库、卸载数据库、终止进程等操作。这种方式，用户有可能正在算账，做复杂报表！一次数据库操作做不完的，在刚做了一次数据库操作后，将被断开，这样对用户有一定影响，启动时不需要实例恢复。 shutdown immediate：阻止任何用户新的连接，同时限制当前连接用户开始新的事务。如果已连接用户有未完成的事务，则数据库系统不会等待他们完成，而是直接把当前未递交的事务回退。数据库系统不再等待用户主动断开连接，当未递交的事务回退成功后，系统会直接关闭、卸载数据库，并终止数据库进程，启动时不需要实例恢复。 shutdown abort：当数据库出现故障时，可能以上三种方式都无法正常关闭数据库，则使用这种方法。强制结束当前正在执行的SQL语句，任何未递交的事务都不被回退！这种方法基本上不会对控制文件或者参数文件造成破坏，这比强制关机要好一点（在无法正常关闭数据库的时候），启动时自动进行实例恢复。 startup相关startup有7个参数：nomount、mount、open、pfile、force、restrict和 startup nomount：通过参数文件，分配sga，启动数据库后台进程，不打开控制文件和数据文件，不能访问数据库。 startup mount：仅给dba进行管理操作，不允许数据库用户访问。仅当前实例的控制文件被打开，数据文件未打开，在这个模式下可以进行如下操作：重命名数据文件、添加取消或重命名重做日志文件、设置归档模式、设置闪回、执行完整的数据库恢复操作等。 startup open：startup的默认参数就是open，打开数据库，允许数据库的访问，当前实例控制文件中所描述的所有文件都已经打开。 startup pfile=FILENAME：以FILENAME为初始化文件启动数据库，不是采用默认初始化文件。 startup force：中止当前数据库的运行，并开始重新正常的启动数据库。 startup restrict：只允许具有restricted session权限的用户访问数据库，该模式下登陆者可做如下操作：执行数据库数据的导出或导入、执行数据装载操作用SQL*Loader、暂时阻止一般的用户使用数据、在某个移植过程和升级操作过程中restricted session登陆后可使用ALTER SYSTEM 语句来禁止RESTRICTED SESSION特性ALTER SYSTEM DISABLE RESTRICTED SESSION；如果是在非受限模式下打开的数据库，后来发现需要限制访问，此时可以使用带ENABLE RESTRICTED SESSION 子句的ALTER SYSTEM 语句来完成。 查看相关信息 下面介绍一下如何查看数据库相关的配置，状态等 看当前数据库的状态：select status from V$instance; 查看参数文件的位置：show parameter spfile; 查看控制文件的位置：show parameter control; 查看数据文件的位置：select file_name from dba_data_files; 启动数据库到nomount状态：SQL&gt;startup nomount; 启动数据库到mount状态：SQL&gt;startup mount; 启动数据库到opent状态：SQL&gt;startup;","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://blog.cuteximi.com/tags/Oracle/"}]},{"title":"Dokcer值得你学习吗？","slug":"whyDocker","date":"2018-03-28T09:40:27.000Z","updated":"2018-03-28T09:48:47.000Z","comments":true,"path":"whyDocker/","link":"","permalink":"http://blog.cuteximi.com/whyDocker/","excerpt":"","text":"0 随着用户需求多样化，软件开发愈加复杂，所依赖的环境愈加的庞大，软件运行环境的迁移是一个巨大的工程。如果需要在别的机器上部署我的软件，就需要花大量的时间来迁移软件依赖的环境，更糟糕的是，全部迁移过去也不一定能运行，这就很尴尬是不是。 1 为了解决这个痛点，虚拟化技术开始普及，比如：虚拟机或者KVM，但是仍然存在性能低，分发麻烦的痛点，注意，这是云时代，这样的解决方案在云时代好像不太适用了。 2 第一代运维以及第二代运维都没有离开SSH，运维过程十分消耗时间。现在随着容器技术的发展，以Docker为代表的技术开始发力，通过容器技术不需要通过ssh+秘钥这种低效的方式来连接服务器，速度得到了极大的提升。 3 Docker放在什么地方威力最大呢？当然是云平台！之前云平台发展缓慢的一个原因就是平台规范标准不一样，各个平台之间无法做到相互兼容，相互对接。每个云平台都有自己独立的资源管理策略，网络映射策略和内部依赖关系。所以一款产品从一个公有云平台“迁移”到另一个公有云平台几乎是不可能的。但是Docker的出现就打破了这种局面。Docker弥补了各个平台之间的差异，Docker屏蔽掉硬件层的差异，提供了统一的用户应用层。 4 谁在用啊？ 京东：Docker扛大旗，弹性伸缩成重点。 微博红包：大规模Docker集群实践经验。 腾讯：万台规模的Docker应用实践。 阿里：全架构PaaS TAE 2.0的Docker实践。 5 如何学习？关注IT充电空间 温馨提示：如果觉得对你有帮助，点赞、转发一下，谢谢各位支持.","categories":[],"tags":[{"name":"dokcer","slug":"dokcer","permalink":"http://blog.cuteximi.com/tags/dokcer/"}]},{"title":"使用AWS服务器优雅的搭建梯子","slug":"aws-vpn","date":"2018-01-31T03:15:47.000Z","updated":"2018-10-11T05:40:58.946Z","comments":true,"path":"aws-vpn/","link":"","permalink":"http://blog.cuteximi.com/aws-vpn/","excerpt":"","text":"轻松搭建私服，如何优雅的使用Google… 更新于2018-10-11，勘误！ 扯一扯 简单：非技术人员也能很快搭建。 快速：花费10分钟你就能创建自己的VPN服务。 私有：提供仅供你使用的VPN。 安全：连接加密且连接VPN服务器时不保留日志信息。 可控：根据需求随时开始或者中断VPN服务。 全球性：可以在9个世界范围内的区域创建一个或者多个的VPN服务。 设备支持：支持PPTP、L2TP(IPSEC)，意味着你可以在Android、iPhone、iPad、MAC等设备上使用VPN服务。 必备条件 信用卡 邮箱 手机号 注册AWS账号为了减少本文长度，注册过程略过，我相信这部分对于大家都没有任何问题。 搭建服务器注册完成之后，进入控制面板中心，选择EC2 找到启动实例按钮。 选择实例并配置我选择是：Ubuntu Server 16.04 LTS (HVM), SSD Volume Type - ami-1ee65166 直接点击审核和启动 点击启动 在弹出的页面，选择创建密钥对 填好名称之后，点击下载密钥对，下载完成之后，保存好记住位置，这样才能进行下一步 这样，等待服务器实例创建完成就可以，喝杯茶 查看实例现在是启动成功之后的状态。接下来吗，我们要使用物理机去连接这个服务器，开始搭建shadowsocks 点击连接 会弹出这个页面，只需要关注红线圈出的位置，点击复制这一部分。 在你刚刚下载的密钥对文件的所在目录下，打开命令行，把刚刚复制的命令粘进去 命令如下 输入yes 连接成功！ 搭建shadowsocks服务命令$ sudo apt-get update //更新apt-get $ sudo apt-get install python-pip //安装pip工具，用于安装shadowsocks $ sudo pip install --upgrade pip //更新pip $ sudo pip install shadowsocks //安装shadowsocks $ sudo vim ~/shadowsocks_conf.json //编辑shadowsocks配置，见下面 shadowsocks_conf.json的内容： { &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;port_password&quot;: { &quot;8388&quot;: &quot;密码&quot; }, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;auth&quot;: true } 启动shadosocks服务$ sudo ssserver -c ~/shadowsocks_conf.json -d start //启动shadowsocks 启动成功如图： 编辑EC2入站规则 至此，VPN服务器就搭建完毕了。 后记服务搭建好了，使用客户端去连接就好了。 手机端推荐影梭app 电脑推荐 https://github.com/shadowsocks/shadowsocks-windows 安卓：https://github.com/shadowsocks/shadowsocks-android/releases 如果搭建过程中出现任何不懂得地方，可以联系我。 关注微信公众号：码省理工 | 头条号：陶哥的干货圈 邮箱：aikuyun.tsl@gmail.com QQ:1534761445 推荐阅读 也可以这也样使用Google搜索","categories":[{"name":"随笔","slug":"随笔","permalink":"http://blog.cuteximi.com/categories/随笔/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"http://blog.cuteximi.com/tags/AWS/"},{"name":"VPN","slug":"VPN","permalink":"http://blog.cuteximi.com/tags/VPN/"}]},{"title":"这样也可以使用google","slug":"这样也可以使用google","date":"2017-11-10T10:10:24.000Z","updated":"2017-11-10T10:13:00.000Z","comments":true,"path":"这样也可以使用google/","link":"","permalink":"http://blog.cuteximi.com/这样也可以使用google/","excerpt":"","text":"这几个网站，无需科学上网，就可以使用Google搜索的服务 没办法使用google的同学们请注意啦，你还在使用百度搜索吗？给你们推荐几款google的替代品，搜索结果来自Google,无需科学上网。 uol buscahttps://busca.uol.com.br/ Rambler.ru是俄罗斯的门户网站 ，谷歌提供技术支持，比百度良心9999999倍！ Mezw经过简单的关键词搜索，国内正常访问，界面简洁。 https://so.mezw.com Bird.sohttp://bird.so/ 关于技术问题是。来自google,雅虎，必应搜索的聚合，经测试，优先展示google搜索的内容。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://blog.cuteximi.com/categories/随笔/"}],"tags":[{"name":"Google","slug":"Google","permalink":"http://blog.cuteximi.com/tags/Google/"}]},{"title":"Shiro概念篇","slug":"Shiro概念篇","date":"2017-09-19T01:05:46.000Z","updated":"2017-09-19T01:06:17.000Z","comments":true,"path":"Shiro概念篇/","link":"","permalink":"http://blog.cuteximi.com/Shiro概念篇/","excerpt":"","text":"看博主系列 开涛的博客以下是学习笔记： Authentication:身份认证，验证用户是不是已经拥有相应的身份；Authorization:授权，即权限验证，验证某个已认证的用户是否拥有某个权限：也就是判断用户能不能做这个事情；Session Manager：会话管理，即用户登录一次就是一次会话，在没有退出之前，他所有会话的信息都保存会话中；Cryptography:加密，保护数据的安全性；Web Support：Web支持，可以很容易集成到web环境；Concurrency；shiro支持多线程应用的并发验证，即在一个线程中开启另一个线程，能把去权限自动传播过去；Testing: 提供测试支持；Run As: 允许一个用户假装另一个用户的身份访问；Remember Me: 记住我，即一次登录之后，下次登陆再来的话不用在登陆； shiro不会去维护用户，维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给shiro 直接与代码交互的对象是Subject，也就是说Shiro对外API的核心是SubjectSubject: 主体，代表当前“用户”，所有的Subject都绑定到SecurityManager，都委托给SecurityManager, SUbject相当于门面，而SecurityManager才是实际的执行者；SecurityManager：我是安全管理器，所有有安全相关的操作，都会交给我来处理，我管理着所有的Subject，我是核心，我负责与其他组件进行交互，你也可以你把我比作springmvc里面的前端控制器，Realm: 我叫域，Shiro要从我这里获取安全数据（用户，角色，权限），也就是说SecurityManager要验证身份，需要从我这里获取相应用户的身份，也需要从我这里获取权限，可以把我 看作安全数据源； 从上面也可以看出，Shiro不提供维护用户和权限，而是用过Realm让开发人员自己注入； Subject: 主体SecurityManager:心脏Authentication:认证器Authorizer: 授权器Realm:可以有一个或者多个，安全的实体数据源SessionManager: Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境SessionDao:CacheManager:缓存控制器 ，放到 缓存中可以提高访问性能；Cryptography: 密码模块；","categories":[{"name":"框架","slug":"框架","permalink":"http://blog.cuteximi.com/categories/框架/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://blog.cuteximi.com/tags/Shiro/"}]},{"title":"Spring中的单例和多例","slug":"Spring中的单例和多例","date":"2017-09-19T01:04:22.000Z","updated":"2017-09-19T01:04:45.000Z","comments":true,"path":"Spring中的单例和多例/","link":"","permalink":"http://blog.cuteximi.com/Spring中的单例和多例/","excerpt":"","text":"直接上配置： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\"> &lt;bean id=\"helloWorld\" class=\"com.HelloWorld\" scope=\"prototype\" init-method=\"init\" destroy- method=\"destroy\">&lt;/bean> &lt;/beans> 其中：init-method，该方法是由spring容器去执行法人，在构造函数之后执行；destroy-method，如果是单例模式，则spring容器关闭或者销毁的时候，会执行该方法；如果是多例模式，则spring容器不负责销毁； 说明：①：如果想让spring容器管理bean的生命周期，那么该bean必须为单例。②：当一个bean在多例模式下，lazy-init为false或者default失效.③：单例模式下，lazy-init可以避免预处理","categories":[{"name":"框架","slug":"框架","permalink":"http://blog.cuteximi.com/categories/框架/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.cuteximi.com/tags/Spring/"}]},{"title":"SpringMVC接受参数","slug":"SpringMVC接受参数","date":"2017-09-19T00:59:01.000Z","updated":"2017-09-19T01:02:11.000Z","comments":true,"path":"SpringMVC接受参数/","link":"","permalink":"http://blog.cuteximi.com/SpringMVC接受参数/","excerpt":"","text":"1.@PathVariable和@RequestParam的区别请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value = “/page/{id}”, method = RequestMethod.GET)2.@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。简介：handler method 参数绑定常用的注解,我们根据他们处理的Request的不同内容部分分为四类：（主要讲解常用类型）A、处理requet uri 部分这里指uri template中variable，不含queryString部分）的注解： @PathVariable; B，处理request header部分的注解： @RequestHeader, @CookieValue;图示： C、处理request body部分的注解：@RequestParam, @RequestBody; D、处理attribute类型是注解： @SessionAttributes, @ModelAttribute;","categories":[{"name":"框架","slug":"框架","permalink":"http://blog.cuteximi.com/categories/框架/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://blog.cuteximi.com/tags/SpringMVC/"}]},{"title":"数组扩容问题","slug":"数组扩容问题","date":"2017-09-19T00:52:45.000Z","updated":"2017-09-19T00:53:33.000Z","comments":true,"path":"数组扩容问题/","link":"","permalink":"http://blog.cuteximi.com/数组扩容问题/","excerpt":"","text":"用数组模拟栈 数组是固定大小的，不能改变长度，要想达到数组扩容的目的，就只能把当前数组复制到一个更长长度的数组中； 使用Arrays.copyOf()方法源码如下： public static short[] copyOf(short[] original, int newLength) { short[] copy = new short[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 可以看出，内部调用了System.arraycopy()方法。 下面是用数组实现一个栈的代码： class MinStack { /** initialize your data structure here. */ int[] stack ;//数组 int defaultSize = 2;//默认大小 int realNumber;//存在的数量 public MinStack() { this.stack = new int[defaultSize]; } public void push(int x) { if(realNumber == stack.length){ stack = Arrays.copyOf(stack,stack.length+defaultSize); } stack[realNumber++] = x; } public void pop() { if(realNumber > 0){ realNumber--; } } public int top() { return stack[realNumber-1]; } public int getMin() { int min = stack[0]; for(int i = 0;i &lt; realNumber;i++){ if(min > stack[i]){ min = stack[i]; } } return min; } }","categories":[{"name":"编程","slug":"编程","permalink":"http://blog.cuteximi.com/categories/编程/"}],"tags":[{"name":"array","slug":"array","permalink":"http://blog.cuteximi.com/tags/array/"}]},{"title":"关于我","slug":"关于我","date":"2017-09-12T05:05:42.000Z","updated":"2018-09-19T06:28:49.576Z","comments":true,"path":"关于我/","link":"","permalink":"http://blog.cuteximi.com/关于我/","excerpt":"","text":"你知道吗？ 我要成为….更牛*的人！ 这是我设计的logo，简单，扁平化的设计带给人大方的气质，色彩仿照google的色彩搭配。 本人，男，地地道道山东人，就读于青岛科技大学，双非学校，软件工程专业，不过没关系，对未来，我还是充满斗志的！向往北上广的生活，压力就是我的动力。喜欢写东西，不过文采不好，但也不影响我写作的热情，写作作为生活的一部分，带给我分享的乐趣，慢慢的提升自己。希望自己的未来，也像那个logo一样，散发自己独特的精彩！贴一下自己的简历——————嘻嘻————— 陶世磊 认真搞定一切22岁 邮箱：aikuyun.tsl@gmail.com 个人博客www.cuteximi.com手机号：139-**-0727 QQ:1534761445 教育背景2014.9-至今 青岛科技大学 软件工程（本科） 个人技能能够使用C++,C语言编写程序。（更新于2018年1月）熟悉运用java基础，数组，集合，多线程，IO,网络编程（TCP）熟悉使用javaWeb的开发,熟悉使用JSP, servlet, Ajax熟悉使用Spring, SpringMVC, Mybatis整合开发,能实际开发J2EE项目熟悉使用javascript,HTML,CSS .了解 Layui, Vue, Bootstrap, Node熟悉使用数据库mysql,了解Mariadb, Redis, MongoDB熟悉使用Tomcat，了解Ngnix熟悉使用maven, git.能够协作开发，熟悉使用github了解Shiro，SpringBoot,熟悉Struts2, Hibernate，了解Docker, Linux 项目经验2016.7-2016.9 烟草配方管理系统 C#系统维护项目职责：独立完成升级录入信息模块。开发环境：vs2005,SQL server2005，mvc设计模式；开发模块： 录入信息模块：将第一版程序录入模块升级改造，升级为烟草配方文件一键导入到系统中；技术要点：1.采用C#控件读取电子表格的每一行数据，加入到数据库中；2.引用的com组件：Microsoft.Office.Interop.Excel.dll 读取EXCEL文件 2017.2-2017.3 西米商城 java后台开发项目职责：编写用户模块开发环境：IDEA, JDK1.8, Tomcat8.0, Mysql5.7，Spring4.3.8,开发模块： 用户模块（登录，注册，修改个人信息，忘记密码）技术要点：1.session管理用户的状态2.MD5加盐加密3.登录验证码：使用kaptcha与spring整合，基于xml配置文件4.横向，纵向越权的安全漏洞5.高复用的服务响应对象的设计以及抽象封装6.Mybatis-plugins插件，方便开发 2016.12-2016.12 问答社区 java开发项目职责：①后台框架搭建 ④接口的设计和编写开发环境：IDEA, JDK1.8, Tomcat8.0, Mysql5.7， Velocity , Git 2.9, SpringBoot Mybatis开发模块： 问题发布模块， 用户个人中心，评论模块技术要点：1.采用 springboot +mybatis搭建基础项目2 MD5密码加密（加盐处理）3.数据库mysql4.采用git进行项目版本控制5.使用velocity进行页面渲染6.拦截器，拦截token7.实现过滤算法，过滤垃圾关键词，色情词汇 2017.5-2017.7 观鸟比赛系统 Java后台开发项目职责：①编写需求分析 ②参与数据库设计 ③后台框架搭建 ④接口的设计和编写开发环境：IDEA, JDK1.8, Tomcat8.0, Mysql5.7，Redis3.2, Bootstarp3.0, Git 2.9, Spring4.3.8, Centos7.4,Jquery1.9 Docker 17.0.6开发模块： 管理员模块， 用户模块，裁判模块, 鸟种记录模块, 权限管理，比赛队伍模块技术要点：1.采用 spring, spring MVC,mybatis搭建基础项目（用到spring IOC AOP管理事务，mvc三层）2.日志采用log4j （基于配置xml的配置）3.MD5密码加密（加盐处理）4.使用mybatis处理灵活查询和关系映射，使用mapper代理的方式5.数据库mysql,redis缓存(strings，hashes，lists，sets，sorted sets ）6.采用git进行项目版本控制7.部署环境linux（Centos7.4）8.使用bootstrap进行页面渲染（栅格系统+拿来即用的样式+自定义根据需求加载样式）9.ajax异步请求，刷新，基于jQuery实现10.前后台使用Json传输数据格式(其中使用自定义泛型类封装返回的status,msg,data属性)11.使用了基于restful风格的url12.后台管理使用jsp接受控制层返回的ModelAndView, 前台比赛系统接受json数据13.后台部分使用shiro进行权限管理14.dokcer进行服务器环境的搭建docker pull，制作镜像vim Dockerfile–&gt;docker build，开启镜像 dockerrun -d -p:端口号15.junit单元测试(使用注解@RunWith(SpringJUnit4ClassRunner.class),@ContextConfigration(locals=”xml 位置”))，进行单元测试16.使用postman调试接口 2017.8-2017.9 青岛航空项目 java开发项目职责：①编写需求分析 ②参与数据库设计 ③后台框架搭建 ④接口的设计和编写开发环境：IDEA, JDK1.8, Tomcat8.0, Mysql5.7， Bootstarp3.0, Git 2.9, Spring4.3.8,,Jquery1.9开发模块： 管理员模块， 用户模块，航班模块，订单模块技术要点：1.采用 spring, spring MVC,mybatis搭建基础项目2.日志采用log4j （基于配置xml的配置）3.MD5密码加密（加盐处理）5.数据库mysql6.采用git进行项目版本控制7.使用layui进行页面渲染9.ajax异步请求，刷新，基于jQuery实现10.前后台使用Json传输数据格式11.后台部分使用shiro进行权限管理12.短信登录验证码13.接入支付宝第三方支付14.处理高并发订票 最近在学习 Linux系统 大数据基础 校园经历①获得院级奖学金 ②两次青岛啤酒节优秀志愿者 ③大学公益社团文艺部部长 ④大二到大三期间担任校园O2O平台59store校园经理，带领团队营销创业。 自我评价1.做事认真负责，处事灵活，不拘泥于现有的方案，有独立的研发能力；2.做事专注，投入度比较高，不被外物干扰，热爱互联网行业；3.很好的抗压能力，以及学习能力，阅读英文文档的能力；4.喜欢写作，每天一篇技术或者生活分享，有个人博客，个人公众号;5.每天坚持总结工作 好了！建立博客的初衷就是提高自己的表达，释放自己的写作欲望，在文字的世界里表达自己的内心，这也是一个愉快的过程，每天都在坚持：当然，下面是主要的写作战场：最开始的战场是 基于hexo搭建的博客-认真搞定一切主要的战场是在这儿 简书个人博客今年开始抵达到这儿 CSDN主页个人微信公众号（尽量周更）：","categories":[],"tags":[]},{"title":"Thread","slug":"Thread","date":"2017-08-20T01:10:42.000Z","updated":"2017-09-12T05:04:45.000Z","comments":true,"path":"Thread/","link":"","permalink":"http://blog.cuteximi.com/Thread/","excerpt":"","text":"多线程理解程序、进程、线程的概念程序可以理解为静态的代码进程可以理解为执行中的程序。线程可以理解为进程的进一步细分，程序的一条执行路径 什么时候需要多线程？ 程序需要执行两个或者多个任务 程序需要实现一些等待的任务时，如用户操作，文件读写操作，网络操作，搜索等。 需要一些后台运行的程序时。多线程的优势. 减少程序的响应时间； 线程切换的花销小； 使用多线程可以简化程序的结构，使得程序便于理解和维护；如何创建线程（重点）文字表述创建线程的两种方法：继承Thread类1) 定义子类继承Thread类。2) 子类中重写Thread类中的run方法。3) 创建Thread子类对象，即创建了线程对象。4) 调用线程对象start方法：启动线程，调用run方法实现Runnable接口1）定义子类，实现Runnable接口。2）子类中重写Runnable接口中的run方法。3）通过Thread类含参构造器创建线程对象。4）将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法中。5）调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。代码表示： 继承于Thread类 /** * Created by 陶世磊 on 2017/8/20. * * @Description: */ class PrintNum extends Thread{ public void run(){//子线程执行的代码 for(int i = 1;i &lt;= 100;i++){ if(i % 2 == 0){ System.out.println(Thread.currentThread().getName() + \":\" + i); } } } public PrintNum(String name){ super(name); } } public class TestThread { public static void main(String[] args) { PrintNum p1 = new PrintNum(\"线程1\"); PrintNum p2 = new PrintNum(\"线程2\"); p1.setPriority(Thread.MAX_PRIORITY);//10 p2.setPriority(Thread.MIN_PRIORITY);//1 p1.start(); p2.start(); } } 方式二：实现Runnable接口 /** * Created by 陶世磊 on 2017/8/20. * * @Description: */ class SubThread implements Runnable{ public void run(){//子线程执行的代码 for(int i = 1;i &lt;= 100;i++){ if(i % 2 == 0){ System.out.println(Thread.currentThread().getName() + \":\" + i); } } } } public class TestThread{ public static void main(String[] args){ SubThread s = new SubThread(); Thread t1 = new Thread(s); Thread t2 = new Thread(s); t1.setName(\"线程1\"); t2.setName(\"线程2\"); t1.start(); t2.start(); } } 两种方式的对比：联系：class Thread implements Runnable比较哪个好？实现的方式较好。①解决了单继承的局限性。②如果多个线程有共享数据的话，建议使用实现方式，同时，共享数据所在的类可以作为Runnable接口的实现类。 线程里的常用方法：start() run() currentThread() getName()setName(String name) yield() join() sleep() isAlive()getPriority() setPriority(int i)； wait() notify() notifyAll() 线程的生命周期new runnable running block dead可以通过getState()方法来获取线程当前的状态 新生状态在程序中用构造方法（new操作符）创建一个新线程时，如new Thread(r)，该线程就是创建状态，此时它已经有了相应的内存空间和其它资源，但是还没有开始执行。 就绪状态 新建线程对象后，调用该线程的 start()方法就可以启动线程。当线程启动时，线程进入就绪状态（runnable）。由于还没有分配CPU，线程将进入线程队列排队，等待 CPU 服务，这表明它已经具备了运行条件。当系统挑选一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态。系统挑选的动作称之为“CPU调度”。一旦获得CPU线程就进入运行状态并自动调用自己的run方法。 运行状态当就绪状态的线程被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的 run()方法。 run()方法定义了该线程的操作和功能。运行状态中的线程执行自己的run方法中代码。直到调用其他方法或者发生阻塞而终止。 阻塞状态 一个正在执行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入输出操作时，将让出 CPU 并暂时中止自己的执行，进入堵塞状态。在可执行状态下，如果调用 sleep()、 suspend()、 wait()等方法，线程都将进入堵塞状态。堵塞时，线程不能进入排队队列，只有当引起堵塞的原因被消除后，线程转入就绪状态。重新到就绪队列中排队等待，这时被CPU调度选中后会从原来停止的位置开始继续执行。 记住：阻塞被消除后是回到就绪状态，不是运行状态。 死亡状态线程调用 stop()方法、destory()方法或 run()方法执行结束后，线程即处于死亡状态。处于死亡状态的线程不具有继续运行的能力。不推荐使用stop()方法【会产生异常】 destory()方法【destory是强制终止，不会释放锁】 同步和异步的区别线程的同步机制（重点）前提：如果我们创建的多个线程，存在着共享数据，那么就有可能出现线程的安全问题：当其中一个线程操作共享数据时，还未操作完成另外的线程就参与进来，导致对共享数据的操作出现问题。解决方式：要求一个线程操作共享数据时，只有当其完成操作完成共享数据，其它线程才有机会执行共享数据。 方式一：同步代码块：synchronized(同步监视器){ //操作共享数据的代码 } 注：1.同步监视器：俗称锁，任何一个类的对象都可以才充当锁。要想保证线程的安全，必须要求所有的线程共用同一把锁！2.使用实现Runnable接口的方式创建多线程的话，同步代码块中的锁，可以考虑是this。如果使用继承Thread类的方式，慎用this!3.共享数据：多个线程需要共同操作的变量，需要明确哪部分是操作共享数据的代码。 方式二：同步方法：将操作共享数据的方法声明为synchronized。比如：public synchronized void show(){ //操作共享数据的代码} 注：1.对于非静态的方法而言，使用同步的话，默认锁为：this。如果使用在继承的方式实现多线程的话，慎用！2.对于静态的方法，如果使用同步，默认的锁为：当前类本身。以单例的懒汉式为例。 Class clazz = Singleton.class总结：释放锁:wait();不释放锁： sleep() yield() suspend() (过时，可能导致死锁)死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁死锁是我们在使用同步时，需要避免的问题！ 线程的通信：如下的三个方法必须使用在同步代码块或同步方法中！wait():当在同步中，执行到此方法，则此线程“等待”，直至其他线程执行notify()的方法，将其唤醒，唤醒后继续其wait()后的代码notify()/notifyAll():在同步中，执行到此方法，则唤醒其他的某一个或所有的被wait的线程。 例题：1.两个线程交替打印1-100自然数2.生产者、消费者的例子 代码实现如下：生产者消费者的例子： package com.cuteximi; /* * 生产者/消费者问题 * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品， * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下， * 如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下， * 如果店中有产品了再通知消费者来取走产品。 分析： 1.是否涉及到多线程的问题？是！生产者、消费者 2.是否涉及到共享数据？有！考虑线程的安全 3.此共享数据是谁？即为产品的数量 4.是否涉及到线程的通信呢？存在这生产者与消费者的通信 */ class Clerk{ int product; public synchronized void addProduct(){//生产产品 if(product >= 20){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } }else{ product++; System.out.println(Thread.currentThread().getName() + \":生产了第\" + product + \"个产品\"); notifyAll(); } } public synchronized void consumeProduct(){//消费产品 if(product &lt;= 0){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } }else{ System.out.println(Thread.currentThread().getName() + \":消费了第\" + product + \"个产品\"); product--; notifyAll(); } } } class Producer implements Runnable{//生产者 Clerk clerk; public Producer(Clerk clerk){ this.clerk = clerk; } public void run(){ System.out.println(\"生产者开始生产产品\"); while(true){ try { Thread.currentThread().sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } clerk.addProduct(); } } } class Consumer implements Runnable{//消费者 Clerk clerk; public Consumer(Clerk clerk){ this.clerk = clerk; } public void run(){ System.out.println(\"消费者消费产品\"); while(true){ try { Thread.currentThread().sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } clerk.consumeProduct(); } } } public class TestThread { public static void main(String[] args) { Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); Consumer c1 = new Consumer(clerk); Thread t1 = new Thread(p1);//一个生产者的线程 Thread t3 = new Thread(p1); Thread t2 = new Thread(c1);//一个消费者的线程 t1.setName(\"生产者1\"); t2.setName(\"消费者1\"); t3.setName(\"生产者2\"); t1.start(); t2.start(); t3.start(); } } 交替打印的例子： package com.cuteximi; //线程通信。如下的三个关键字使用的话，都得在同步代码块或同步方法中。 //wait():一旦一个线程执行到wait()，就释放当前的锁。 //notify()/notifyAll():唤醒wait的一个或所有的线程 //使用两个线程打印 1-100. 线程1, 线程2 交替打印 class PrintNum implements Runnable { int num = 1; Object obj = new Object(); //锁 public void run() { while (true) { synchronized (obj) { obj.notify(); if (num &lt;= 100) { try {//延迟 Thread.currentThread().sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \":\" + num); num++; } else { break; } try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } public class TestThread { public static void main(String[] args) { PrintNum p = new PrintNum(); Thread t1 = new Thread(p); Thread t2 = new Thread(p); t1.setName(\"甲\"); t2.setName(\"乙\"); t1.start(); t2.start(); } } start() run()如果线程直接调用run()方法，这会被当成一个普通的函数来使用，这时，只有一个主线程，然而start()可以异步的调用run()方法，来实现多线程。 基础很重要！","categories":[{"name":"编程","slug":"编程","permalink":"http://blog.cuteximi.com/categories/编程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.cuteximi.com/tags/多线程/"}]},{"title":"float","slug":"float","date":"2017-08-20T00:17:24.000Z","updated":"2017-09-19T00:39:44.000Z","comments":true,"path":"float/","link":"","permalink":"http://blog.cuteximi.com/float/","excerpt":"","text":"区别float是单精度类型,精度是8位有效数字，取值范围是10的-38次方到10的38次方，float占用4个字节的存储空间double是双精度类型，精度是17位有效数字，取值范围是10的-308次方到10的308次方，double占用8个字节的存储空间 说明一点当你不声明的时候，默认小数都用double来表示，所以如果要用float的话，则应该在其后加上f例如：float a=1.3;如图：（如果我不加，编译的时候就会报错！）则会提示不能将double转化成float 这成为窄型转化如果要用float来修饰的话，则应该使用float a=1.3f ps注意float是8位有效数字，第7位数字将会产生四舍五入所以如果一个float变量 这样定义: float a=1.23456785; 则第7位将产生四舍五入(5以下的都将舍去)","categories":[{"name":"编程","slug":"编程","permalink":"http://blog.cuteximi.com/categories/编程/"}],"tags":[{"name":"float","slug":"float","permalink":"http://blog.cuteximi.com/tags/float/"}]},{"title":"docker入门","slug":"docker","date":"2017-08-20T00:15:25.000Z","updated":"2017-08-20T00:26:25.000Z","comments":true,"path":"docker/","link":"","permalink":"http://blog.cuteximi.com/docker/","excerpt":"","text":"什么是Docker官网的描述是这样的： Docker is the world’s leading software container platform. Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 解决了什么问题 Developers use Docker to eliminate “works on my machine” problems when collaborating on code with co-workers. Operators use Docker to run and manage apps side-by-side in isolated containers to get better compute density. Enterprises use Docker to build agile software delivery pipelines to ship new features faster, more securely and with confidence for both Linux, Windows Server, and Linux-on-mainframe apps.应用场景 web应用的自动化打包和发布 自动化测试和持续集成，发布 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 开始安装进入官网：选择相应的版本 安装步骤根据每个系统都写的很详细，在这里我就不再赘述了！安装成功之后，在终端输入 docker version查看安装是否成功 我在linux机器上安装的时候，出的错误： Got permission denied while trying to connect to the Docker daemon socket at Unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.26/images/json: dial Unix /var/run/docker.sock: connect: permission denied 解决方案：把当前用户加入docker用户组。 $sudo gpasswd -a ${USER} docker 查看是否添加成功？ $ cat /etc/group | grep ^docker 重启docker服务 $ sudo service docker restart 最后，如果还不行，请重启或者注销用户，再次登录！ 走进DockerBuild Ship Run 三个关键词Docker镜像：一系列的文件；Docker容器：Docker仓库：网易蜂巢镜像官方镜像 第一个容器例子：jress官网制作自己的容器：1.首先下载jpress的war包，放到工作目录：work2.执行命令，拉取tomcat的镜像,等到拉取完毕，查看镜像 $ docker pull hub.c.163.com/library/tomcat:latest //拉取镜像 ... .... $ docker images //查看镜像 tomcat镜像默认的配置： 3.编写Dockerfile $ sudo vim Dockerfile 加入如下内容：FROM hub.c.163.com/library/tomcat:latestMAINTAINER cuteximi xxX@qq.comCOPY jpress.war /usr/local/webapps 4.Build执行命令： $ docker build . -t jpress:lastest //有个点 运行第一个容器1.查看镜像：docker images发现我们制作好的镜像已经存在了. 2开始启动我们的镜像： $ docker run -d -p 8888:8080 jpress:lastest 3.在浏览器查看我们的项目 docker的命令点击查看命令大全 推荐的学习网站官网中文docker社区csdn的Docker知识库 机会留给有准备的人","categories":[{"name":"docker","slug":"docker","permalink":"http://blog.cuteximi.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.cuteximi.com/tags/docker/"}]},{"title":"ArrayList源码","slug":"ArrayList源码","date":"2017-07-22T12:09:05.000Z","updated":"2017-07-22T12:10:02.000Z","comments":true,"path":"ArrayList源码/","link":"","permalink":"http://blog.cuteximi.com/ArrayList源码/","excerpt":"简介：1.ArrayList是基于数组的，一个动态“数组”，能够自动的扩容； 2.ArrayLIst不线程安全的，只能在单线程下使用，要想在多线程环境下使用，可以使用集合操作类Colletcions.syncronized(List l)方法转化为一个线程安全的ArrayList或者使用concurrent下面的CopyOnWriteArrayList类 3.ArrayList实现了序列化接口Serializable接口，能够序列化传输；实现了RandomAcess接口，支持快速随机访问，（实际上就是用过下标号进行访问）；实现了Cloneable接口，能够被克隆","text":"简介：1.ArrayList是基于数组的，一个动态“数组”，能够自动的扩容； 2.ArrayLIst不线程安全的，只能在单线程下使用，要想在多线程环境下使用，可以使用集合操作类Colletcions.syncronized(List l)方法转化为一个线程安全的ArrayList或者使用concurrent下面的CopyOnWriteArrayList类 3.ArrayList实现了序列化接口Serializable接口，能够序列化传输；实现了RandomAcess接口，支持快速随机访问，（实际上就是用过下标号进行访问）；实现了Cloneable接口，能够被克隆 源码(JDK8)+部分注释 package java.util; import java.util.function.Consumer; import java.util.function.Predicate; import java.util.function.UnaryOperator; public class ArrayList&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, java.io.Serializable { //代码略 } 属性 /** *序列化版本号 */ private static final long serialVersionUID = 8683452581122892189L; /** * Default initial capacity. * 默认初始化的容量 10 */ private static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * 存放元素的数组,从这可以看出来底层就是数组 */ transient Object[] elementData; /** * The size of the ArrayList (the number of elements it contains). * 数组包含元素的个数 */ private int size; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit * 数组的最大上限 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; ArrayList的属性不多，重要的是elementData,声明这个属性的时候使用了transient关键字， transient用来表示一个域不是该对象序行化的一部分。 ArrayList在序列化的时候会调用writeObject，直接将size和element写入ObjectOutputStream；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData。 QA:为什么不直接用elementData来序列化？？ 原因在于elementData是一个缓存数组，他通常会预留一些空间，等容量不足时再扩容，那么有些空间可能并没有实际存在的数据，使用上述方式，实现序列化的时候，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间； 方法构造方法 public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E> c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 1.用户自定义大小 带int类型的构造函数如果传入参数，则代表指定ArrayList的初始数组长度，传入参数如果是大于等于0，则使用用户的参数初始化，如果用户传入的参数小于0，则抛出异常； 2.无参构造器 注意：初始化之后，此时，elementData的长度是1，size是0，那么默认值什么时候起作用呢？ ：）在add的时候，elementData变成默认的长度；（参考源码可见） 3.带Collection对象的构造函数 将Colletion对象转换为数组，然后将数组的地址给elementData；如果elmentData长度为0，直接将 EMPTY_ELEMENTDATA赋给它；如果size的值大于0，则执行Arrays.copy方法，把collection对象的内容（可以理解为深拷贝）copy到elementData中 注意：elementData = c.toArray(); 这里执行的简单赋值时浅拷贝，所以要执行Arrays.copyOf 做深拷贝 get方法 public E get(int index) { //判断是否越界 rangeCheck(index); //返回 return elementData(index); } private void rangeCheck(int index) { if (index >= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } //数组索引 E elementData(int index) { return (E) elementData[index]; } 从上面可以看出： 实际上就是从数组中取值，时间复杂度O(1) add方法 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length > 0) grow(minCapacity); } private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 如上：添加元素时，为了保证有足够的空间添加元素，如果是第一次添加，会将elementData的大小默认为10；如果不是第一次添加元素，就会跳入ensureExplicitCapacity方法，判断比较需要的空间与当前elementData的大小，如果不够，则扩容，即跳入grow()方法，增值原来的1.5倍；此时时间复杂度O(1) public void add(int index, E element) { //检查越界 rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 注意：时间复杂度O(n); set方法 public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; } set会把原来位置上的数据返回； remove方法 public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } 1.remove分两种：index和对象 根据index移除对象，如果是末尾的数据，直接将该位置的元素=null;如果是其他位置，需要将位置后面的元素全部往前移动一个位置，最后将最后一个位置=null; 根据对象，实现找到该对象对应的位置，然后根据位置去删除；（之后，同上）；时间复杂度O(n) indexOf()和lastIndexOf() public int indexOf(Object o) { if (o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1; } public int lastIndexOf(Object o) { if (o == null) { for (int i = size-1; i >= 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i >= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } 一个是从前往后找，一个是从后往前找；时间复杂度是O(n)。 subList() public List&lt;E> subList(int fromIndex, int toIndex) { subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); } 内部类SubList trimToSize() public void trimToSize() { modCount++; if (size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } } 去掉多余的空间； iterator() public Iterator&lt;E> iterator() { return new Itr(); } 内部类Ttr Vecter构造函数 public Vector(int initialCapacity, int capacityIncrement) { super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; } public Vector(int initialCapacity) { this(initialCapacity, 0); } public Vector() { this(10); } 与ArrayList不同的是，Vector在初始化是就创建了数组； grow() private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement > 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } 在没有制定capacityIncrement的情况下，默认扩容方式是2倍；指定了扩容增长因子之后，每次增capacityIncrement大小的容量； 总结ArrayList线程不安全的；Vector线程安全；写累了，歇会；","categories":[],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"http://blog.cuteximi.com/tags/ArrayList/"}]},{"title":"数组与链表","slug":"数组与链表","date":"2017-07-19T06:19:52.000Z","updated":"2017-07-19T06:32:26.000Z","comments":true,"path":"数组与链表/","link":"","permalink":"http://blog.cuteximi.com/数组与链表/","excerpt":"","text":"数组 内存连续的数据结构，每个数据所占的内存相等，所有通过索引很快能查找到相应的数据； 链表 由一系列节点组成，每个节点包括两部分（数据域和下一个节点地址） 区别1.数组在逻辑上连续的数据物理空间上也是连续的，链表不一定； 2.（静态）数组在栈中分配内存，方便，不灵活； 链表在堆中分配内存，动态申请节点空间，不方便管理； 3.数组长度固定，会出现溢出的情况；链表可以根据实际需求伸缩； 4.如果对查询速度有要求的话，使用数组；对插入和删除有要求的话，使用链表；","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.cuteximi.com/categories/数据结构/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://blog.cuteximi.com/tags/数组/"},{"name":"链表","slug":"链表","permalink":"http://blog.cuteximi.com/tags/链表/"}]},{"title":"Express-static","slug":"express-static","date":"2017-07-05T01:36:11.000Z","updated":"2017-07-05T01:45:38.000Z","comments":true,"path":"express-static/","link":"","permalink":"http://blog.cuteximi.com/express-static/","excerpt":"","text":"利用 Express 托管静态文件 通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。 1.将静态资源文件所在的目录作为参数传递给 express.static 中间件就可以提供静态资源文件的访问了。 例如，假设在 public 目录放置了图片、CSS 和 JavaScript 文件，你就可以： app.use(express.static(&#39;public&#39;)); 现在，public 目录下面的文件就可以访问了。 http://localhost:3000/images/kitten.jpg http://localhost:3000/css/style.css http://localhost:3000/js/app.js http://localhost:3000/images/bg.png http://localhost:3000/hello.html 2.所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在 URL 中。如果你的静态资源存放在多个目录下面，你可以多次调用 express.static 中间件： app.use(express.static(&#39;public&#39;)); app.use(express.static(&#39;files&#39;)); //访问静态资源文件时，express.static //中间件会根据目录添加的顺序查找所需的文件 3.如果你希望所有通过 express.static 访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示： app.use(&#39;/static&#39;, express.static(&#39;public&#39;)); 现在，你就可以通过带有 “/static” 前缀的地址来访问 public 目录下面的文件了。 http://localhost:3000/static/images/kitten.jpg http://localhost:3000/static/css/style.css http://localhost:3000/static/js/app.js http://localhost:3000/static/images/bg.png http://localhost:3000/static/hello.html","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.cuteximi.com/tags/Express/"},{"name":"Node","slug":"Node","permalink":"http://blog.cuteximi.com/tags/Node/"}]},{"title":"Express-generator","slug":"express-generator","date":"2017-07-05T01:35:58.000Z","updated":"2017-07-05T01:44:47.000Z","comments":true,"path":"express-generator/","link":"","permalink":"http://blog.cuteximi.com/express-generator/","excerpt":"","text":"Express 应用生成器 通过应用生成器工具 express 可以快速创建一个应用的骨架。 1.通过如下命令安装：$ npm install express-generator -g -h 选项可以列出所有可用的命令行选项： $ express -h Usage: express [options] [dir] Options: -h, --help output usage information -V, --version output the version number -e, --ejs add ejs engine support (defaults to jade) --hbs add handlebars engine support -H, --hogan add hogan.js engine support -c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css) --git add .gitignore -f, --force force on non-empty directory 2.下面的示例就是在当前工作目录下创建一个命名为 myapp 的应用。$ express myapp warning: the default view engine will not be jade in future releases warning: use `--view=jade&#39; or `--help&#39; for additional options create : myapp create : myapp/package.json create : myapp/app.js create : myapp/public create : myapp/routes create : myapp/routes/index.js create : myapp/routes/users.js create : myapp/views create : myapp/views/index.jade create : myapp/views/layout.jade create : myapp/views/error.jade create : myapp/bin create : myapp/bin/www create : myapp/public/images create : myapp/public/javascripts create : myapp/public/stylesheets create : myapp/public/stylesheets/style.css install dependencies: $ cd myapp &amp;&amp; npm install run the app: $ DEBUG=myapp:* npm start 3.然后安装所有依赖包：$ cd myapp $ npm install 4.启动这个应用MacOS 或 Linux 平台： $ DEBUG=myapp npm start Windows 平台使用如下命令： set DEBUG=myapp &amp; npm start 5.然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了。6.通过 Express 应用生成器创建的应用一般都有如下目录结构：. ├── app.js ├── bin │ └── www ├── package.json ├── public │ ├── images │ ├── javascripts │ └── stylesheets │ └── style.css ├── routes │ ├── index.js │ └── users.js └── views ├── error.jade ├── index.jade └── layout.jade 7 directories, 9 files","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.cuteximi.com/tags/Express/"},{"name":"Node","slug":"Node","permalink":"http://blog.cuteximi.com/tags/Node/"}]},{"title":"Express-router","slug":"express-router","date":"2017-07-05T01:35:31.000Z","updated":"2017-07-05T01:44:20.000Z","comments":true,"path":"express-router/","link":"","permalink":"http://blog.cuteximi.com/express-router/","excerpt":"","text":"一个简单的 Express 路由这篇教程只是对 Express 路由做一个简单的介绍。 路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。 每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行。 1.路由的定义由如下结构组成： app.METHOD(PATH, HANDLER)。其中，app 是一个 express 实例；METHOD 是某个 HTTP 请求方式中的一个；PATH 是服务器端的路径；HANDLER 是当路由匹配到时需要执行的函数。 本教程假定已经存在一个命名为 app 的 express 实例了，并且应用程序是运行状态。如果你还不熟悉如何创建一个应用并使其运行，请参考 Hello world 实例。 2.下面的代码展示了几个路由实例： / / 对网站首页的访问返回 &quot;Hello World!&quot; 字样 app.get(&#39;/&#39;, function (req, res) { res.send(&#39;Hello World!&#39;); }); // 网站首页接受 POST 请求 app.post(&#39;/&#39;, function (req, res) { res.send(&#39;Got a POST request&#39;); }); // /user 节点接受 PUT 请求 app.put(&#39;/user&#39;, function (req, res) { res.send(&#39;Got a PUT request at /user&#39;); }); // /user 节点接受 DELETE 请求 app.delete(&#39;/user&#39;, function (req, res) { res.send(&#39;Got a DELETE request at /user&#39;); }); 关于路由的详细资料，请移步官网查看路由指南 章节。","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.cuteximi.com/tags/Express/"},{"name":"Node","slug":"Node","permalink":"http://blog.cuteximi.com/tags/Node/"}]},{"title":"Express-hello","slug":"express-hello","date":"2017-07-05T01:35:22.000Z","updated":"2017-07-05T01:43:46.000Z","comments":true,"path":"express-hello/","link":"","permalink":"http://blog.cuteximi.com/express-hello/","excerpt":"","text":"Hello world 实例我们一起创建一个基本的 Express 应用。 注意：这里所创建是一个最最简单的 Express 应用，并且仅仅只有一个文件 — 和通过 Express 应用生成器 所创建的应用完全不一样，Express 应用生成器所创建的应用框架包含多个 JavaScript 文件、Jade 模板和针对不同用途的子目录。 1.进入 myapp 目录，创建一个名为 app.js 的文件，然后将下列代码复制进去： var express = require(&#39;express&#39;); var app = express(); app.get(&#39;/&#39;, function (req, res) { res.send(&#39;Hello World!&#39;); }); var server = app.listen(3000, function () { var host = server.address().address; var port = server.address().port; console.log(&#39;Example app listening at http://%s:%s&#39;, host, port); }); 解释：上面的代码启动一个服务并监听从 3000 端口进入的所有连接请求。他将对所有 (/) URL 或 路由 返回 “Hello World!” 字符串。对于其他所有路径全部返回 404 Not Found。 req (请求) 和 res (响应) 与 Node 提供的对象完全一致，因此，你可以调用 req.pipe()、req.on(‘data’, callback) 以及任何 Node 提供的方法。通过如下命令启动此应用： $ node app.js 2.然后在浏览器中打开 http://localhost:3000/ 并查看输出结果。","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.cuteximi.com/tags/Express/"},{"name":"Node","slug":"Node","permalink":"http://blog.cuteximi.com/tags/Node/"}]},{"title":"Express-start","slug":"express-start","date":"2017-07-05T01:34:56.000Z","updated":"2017-07-05T01:43:14.000Z","comments":true,"path":"express-start/","link":"","permalink":"http://blog.cuteximi.com/express-start/","excerpt":"","text":"安装首先假定你已经安装了 Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。 $ mkdir myapp $ cd myapp 通过 npm init 命令为你的应用创建一个 package.json 文件。 $ npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受默认设置即可，下面这个除外： entry point: (index.js) 键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。 接下来安装 Express 并将其保存到依赖列表中： $ npm install express --save 如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 –save 参数即可： $ npm install express","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.cuteximi.com/tags/Express/"},{"name":"Node","slug":"Node","permalink":"http://blog.cuteximi.com/tags/Node/"}]},{"title":"Express","slug":"express","date":"2017-07-05T01:34:36.000Z","updated":"2017-07-05T01:55:57.000Z","comments":true,"path":"express/","link":"","permalink":"http://blog.cuteximi.com/express/","excerpt":"","text":"Express 基于 Node.js 平台，快速、开放、极简的 web 开发框架 Web 应用 Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 API 丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。 性能 Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。 入门五步走 开始 hello world expess生成器 简单的路由 托管静态资源 后记让我们来愉快的学习吧！2017.7.5 TSL","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.cuteximi.com/tags/Express/"},{"name":"Node","slug":"Node","permalink":"http://blog.cuteximi.com/tags/Node/"}]},{"title":"Linux实验二","slug":"Linux实验二","date":"2017-07-02T14:09:12.000Z","updated":"2017-07-02T14:10:25.000Z","comments":true,"path":"Linux实验二/","link":"","permalink":"http://blog.cuteximi.com/Linux实验二/","excerpt":"","text":"linux的哲学就是：没有结果就是最好的结果 tabj键补全命令 查看当前所在目录：pwd 按键 作用 Ctrl+d 键盘输入结束或退出终端 Ctrl+s 暂停当前程序，暂停后按下任意键恢复运行 Ctrl+z 将当前程序放到后台运行，恢复到前台为命令fg Ctrl+a 将光标移至输入行头，相当于Home键 Ctrl+e 将光标移至输入行末，相当于End键 Ctrl+k 删除从光标所在位置到行末 Alt+Backspace 向前删除一个单词 Shift+PgUp 将终端显示向上滚动 Shift+PgDn 将终端显示向下滚动 Shell 常用通配符： 字符 含义 *} 匹配 0 或多个字符 ? 匹配任意一个字符 [list] 匹配 list 中的任意单一字符 [!list] 匹配 除list 中的任意单一字符以外的字符 [c1-c2] 匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z] {string1,string2,…} 匹配 string1 或 string2 (或更多)其一字符串 {c1..c2} 匹配 c1-c2 中全部字符 如{1..10}","categories":[{"name":"动手实验搭建环境","slug":"动手实验搭建环境","permalink":"http://blog.cuteximi.com/categories/动手实验搭建环境/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.cuteximi.com/tags/Linux/"}]},{"title":"Pages上部署自己的简历","slug":"Pages上部署自己的简历","date":"2017-07-02T07:42:03.000Z","updated":"2017-07-04T02:19:23.000Z","comments":true,"path":"Pages上部署自己的简历/","link":"","permalink":"http://blog.cuteximi.com/Pages上部署自己的简历/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux入门","slug":"Linux入门","date":"2017-07-02T06:49:52.000Z","updated":"2017-07-02T07:28:48.000Z","comments":true,"path":"Linux入门/","link":"","permalink":"http://blog.cuteximi.com/Linux入门/","excerpt":"Linux基础入门目录，文件mkdir创建目录; cd 进入; cd ../ 返回上一级; mv 移动; rm -rm 删除目录; ls显示目录下的文件; touch 新建文件; cp复制文件; rm 删除文件; cat查看文件;","text":"Linux基础入门目录，文件mkdir创建目录; cd 进入; cd ../ 返回上一级; mv 移动; rm -rm 删除目录; ls显示目录下的文件; touch 新建文件; cp复制文件; rm 删除文件; cat查看文件; 过滤,通道，重定向1.过滤出 /etc/passwd 文件中包含 root 的记录 grep &#39;root&#39; /etc/passwd 2.递归地过滤出 /var/log/ 目录中包含 linux 的记录 grep -r &#39;linux&#39; /var/log/ 3.将 cat 和 grep 两个命令用管道组合在一起 cat /etc/passwd | grep &#39;root&#39; 4.过滤出 /etc 目录中名字包含 ssh 的目录(不包括子目录) ls /etc | grep &#39;ssh&#39; 5.可以使用 &gt; 或 &lt; 将命令的输出重定向到一个文件中 echo &#39;Hello World&#39; &gt; ~/test.txt 运维命令1.对 cloud.tencent.com 发送 4 个 ping 包, 检查与其是否联通 ping -c 4 cloud.tencent.com 2.netstat 命令用于显示各种网络相关信息，如网络连接, 路由表, 接口状态等等 1)列出所有处于监听状态的tcp端口 netstat -lt 2)查看所有的端口信息, 包括 PID 和进程名称 netstat -tulpn 3.ps进程,过滤得到当前系统中的 ssh 进程信息 ps -aux |grep &#39;ssh&#39;","categories":[{"name":"动手实验搭建环境","slug":"动手实验搭建环境","permalink":"http://blog.cuteximi.com/categories/动手实验搭建环境/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.cuteximi.com/tags/Linux/"}]},{"title":"springBoot开始(一)","slug":"springBoot开始","date":"2017-07-02T05:31:09.000Z","updated":"2017-07-02T14:32:42.000Z","comments":true,"path":"springBoot开始/","link":"","permalink":"http://blog.cuteximi.com/springBoot开始/","excerpt":"开始 Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.","text":"开始 Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. Features Create stand-alone Spring applications Embed Tomcat,Jetty or Undertow directory(no need to deploy WAR files) Automasticclly configure Spring whenever possible Provide production-ready features such as metrics,health checks and externalized configuration Absolutely no code generation and no description of all the features,plus an extensive howto for common user cases. 什么是spring boot Spring Boot 充分利用了 JavaConfig 的配置模式以及“约定优于配置”的理念，能够极大的简化基于 Spring MVC 的 Web 应用和 REST 服务开发。对于已经熟悉 Spring 生态系统的开发人员来说，Spring Boot 是一个很理想的选择。Spring Boot提供了很多”开箱即用“的依赖模块，都是以spring-boot-starter-xx作为命名的。下面列举一些常用的模块。 spring的相关模块 Spring Boot提供了很多”开箱即用“的依赖模块，都是以spring-boot-starter-xx作为命名的。下面列举一些常用的模块。 spring-boot-starter-logging ：使用 Spring Boot 默认的日志框架 Logback。 spring-boot-starter-log4j ：添加 Log4j 的支持。 spring-boot-starter-web ：支持 Web 应用开发，包含 Tomcat 和 spring-mvc。 spring-boot-starter-tomcat ：使用 Spring Boot 默认的 Tomcat 作为应用服务器。 spring-boot-starter-jetty ：使用 Jetty 而不是默认的 Tomcat 作为应用服务器。 spring-boot-starter-test ：包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。 spring-boot-starter-aop ：包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）。 spring-boot-starter-security ：包含 spring-security。 spring-boot-starter-jdbc ：支持使用 JDBC 访问数据库。 spring-boot-starter-redis ：支持使用 Redis。 spring-boot-starter-data-mongodb ：包含 spring-data-mongodb 来支持 MongoDB。 spring-boot-starter-data-jpa ：包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。 spring-boot-starter-amqp ：通过 spring-rabbit 支持 AMQP。 spring-boot-starter-actuator ： 添加适用于生产环境的功能，如性能指标和监测等功能。 Java Config 自动配置Spring Boot 推荐采用基于 Java Config 的配置方式，而不是传统的 XML。例如，@Configuration、@Bean、@EnableAutoConfiguration、@CompomentScan、@PropertySource、@Repository、@Service、@RestController等。 快速开始1.新建一个空的maven项目2.修改pom.xml,添加： &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>1.5.3.RELEASE&lt;/version> &lt;/parent> &lt;dependencies> &lt;!--开始搭建spring boot应用--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;version>1.5.3.RELEASE&lt;/version> &lt;/dependency> &lt;!--创建web项目要加入的依赖--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;version>1.5.3.RELEASE&lt;/version> &lt;/dependency> &lt;/dependencies> 3.新建java demo文件： package com.cuteximi.go; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; /** * Created by 陶世磊 on 2017/7/2. * * @Description: */ @SpringBootApplication public class ApplicationDemo { public static void main(String[] args) throws Exception{ System.out.println(\"SpringApplication Run!\"); SpringApplication.run(ApplicationDemo.class,args); } } 4.新建contorller demo package com.cuteximi.go; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * Created by 陶世磊 on 2017/7/2. * * @Description: */ @RestController @EnableAutoConfiguration public class RestfulApplicationDemo { @RequestMapping(\"/\") public String home(){ return \"Hello Spring Boot Web!\"; } @RequestMapping(\"/hello\") public String hello(){ return new String(\"hello\"); } public static void main(String[] args) throws Exception{ SpringApplication.run(RestfulApplicationDemo.class,args); } } 注解 区别 @RestController 该注解包含@Controller和@ResponseBody,里面的方法无法返回jsp页面 @Controller 配合视图解析器InternalResourceViewResolver使用，返回界面 @ResponseBody 返回JSON,XMl或者自定义的mediaType 结尾附上pom.xml文件的内容： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>firstSpringBoot&lt;/groupId> &lt;artifactId>cuteximi&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>1.5.3.RELEASE&lt;/version> &lt;/parent> &lt;dependencies> &lt;!--开始搭建spring boot应用--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;version>1.5.3.RELEASE&lt;/version> &lt;/dependency> &lt;!--创建web项目要加入的依赖--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;version>1.5.3.RELEASE&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;!--该插件，运行“mvn package”进行打包时，会打包成一个可以直接运行的JAR文件， 使用java -jar命令就可以直接运行--> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 后面 机会是留给有准备的人的！","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.cuteximi.com/tags/Spring-Boot/"}]},{"title":"实验基地啊！","slug":"动手实验","date":"2017-06-30T14:33:44.000Z","updated":"2017-07-02T06:49:07.000Z","comments":true,"path":"动手实验/","link":"","permalink":"http://blog.cuteximi.com/动手实验/","excerpt":"","text":"开头 自学的路上要明确自己的方向！ 腾讯提供的实验室： 点我进入啊 还有一个实验楼：点我进入实验楼 最后TSL,加油吧。","categories":[{"name":"动手实验搭建环境","slug":"动手实验搭建环境","permalink":"http://blog.cuteximi.com/categories/动手实验搭建环境/"}],"tags":[{"name":"学习实验室","slug":"学习实验室","permalink":"http://blog.cuteximi.com/tags/学习实验室/"}]},{"title":"团队","slug":"团队","date":"2017-06-23T13:46:21.000Z","updated":"2017-06-23T14:10:56.000Z","comments":true,"path":"团队/","link":"","permalink":"http://blog.cuteximi.com/团队/","excerpt":"","text":"篮球赛不管是三年前的我们，还是现在的我们都是最棒的，青科软件最团结。下面是我们的皂片（青科软件威武！）(都是原图，加载可能很慢==) 抽空回崂山把篮球鞋拿过来（ps:远远不是大一的身体了，该加强身体锻炼了，别一直coding…..）","categories":[{"name":"篮球","slug":"篮球","permalink":"http://blog.cuteximi.com/categories/篮球/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://blog.cuteximi.com/tags/生活/"}]},{"title":"英语学习","slug":"英语角","date":"2017-06-22T13:58:54.000Z","updated":"2017-06-22T14:14:03.000Z","comments":true,"path":"英语角/","link":"","permalink":"http://blog.cuteximi.com/英语角/","excerpt":"","text":"我对于英语的兴趣写在前面 我对于英语的兴趣源于小时候爸爸对我的引导，我很小的时候，我爸开始教我说各种生活用品的英语。应试教育之下的压迫，自己对于英语的兴趣，使得我对英语又爱又恨。 I love the software business and I can do it myself.I loved logic, math, computer programmin.I want to go to Shanghai to realize my value.But that is only a dream, but I would have worked. 写在后面The most important is, keep on studying everyday, one step at a time,” never forget to take one meal “","categories":[],"tags":[{"name":"英语","slug":"英语","permalink":"http://blog.cuteximi.com/tags/英语/"}]},{"title":"换个主题","slug":"theme","date":"2017-06-22T13:31:54.000Z","updated":"2017-06-22T13:33:58.000Z","comments":true,"path":"theme/","link":"","permalink":"http://blog.cuteximi.com/theme/","excerpt":"","text":"换个主题，明天篮球赛，加油撒！","categories":[],"tags":[{"name":"theme","slug":"theme","permalink":"http://blog.cuteximi.com/tags/theme/"}]},{"title":"comeon","slug":"comeon","date":"2017-06-21T14:15:27.000Z","updated":"2017-06-22T12:37:07.000Z","comments":true,"path":"comeon/","link":"","permalink":"http://blog.cuteximi.com/comeon/","excerpt":"","text":"世界上最大的同性交友平台——github","categories":[{"name":"资料库","slug":"资料库","permalink":"http://blog.cuteximi.com/categories/资料库/"}],"tags":[{"name":"github","slug":"github","permalink":"http://blog.cuteximi.com/tags/github/"}]},{"title":"java手册（阿里）","slug":"java手册（阿里）","date":"2017-06-20T01:59:24.000Z","updated":"2017-06-22T12:34:26.000Z","comments":true,"path":"java手册（阿里）/","link":"","permalink":"http://blog.cuteximi.com/java手册（阿里）/","excerpt":"前言： 代码规范真的很重要。看别人的代码写的代码，没有注释，变量名很糟糕，格式不规范，真的很难忍受啊。自己在实际开发也存在不规范的地方，今天仔细拜读一下阿里的开发手册，吸收一下前辈总结的经验。","text":"前言： 代码规范真的很重要。看别人的代码写的代码，没有注释，变量名很糟糕，格式不规范，真的很难忍受啊。自己在实际开发也存在不规范的地方，今天仔细拜读一下阿里的开发手册，吸收一下前辈总结的经验。 编程规约命名风格 【强制】 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 反例： name / __name / $Object / name / name$ / Object$ 【强制】 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。 正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。 反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO /DTO / VO / AO 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。 正例： localValue / getHttpMessage() / inputUserId 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例： MAX_STOCK_COUNT反例： MAX_COUNT 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。 【强制】中括号是数组类型的一部分，数组定义如下：String[] args; 反例：使用 String args[]的方式来定义。 【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。 反例：定义为基本数据类型 Boolean isDeleted；的属性，它的方法也是 isDeleted()，RPC框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用==单数==形式，但是类名如果有复数含义，类名可以使用复数形式。 正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考spring 的框架结构） 【强制】杜绝完全不规范的缩写，避免望文不知义。 反例： AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。 正例：public class OrderFactory;public class LoginProxy;public class ResourceObserver; 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。 正例：接口方法签名：void f(); 接口基础常量表示：String COMPANY = “alibaba”;反例：接口方法定义：public abstract void f();说明：JDK8 中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默 认实现。 接口和实现类的命名有两套规则： 1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。正例：CacheServiceImpl 实现 CacheService 接口。2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。正例：AbstractTranslator 实现 Translatable。 【参考】枚举类名建议带上 Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。 说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。正例：枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。 【参考】各层命名规约： (A) Service/DAO 层方法命名规约 - 1） 获取单个对象的方法用 get 做前缀。 - 2） 获取多个对象的方法用 list 做前缀。 - 3） 获取统计值的方法用 count 做前缀。 - 4） 插入的方法用 save（推荐）或 insert 做前缀。 - 5） 删除的方法用 remove（推荐）或 delete 做前缀。 - 6） 修改的方法用 update 做前缀。 - B) 领域模型命名规约 - 1） 数据对象：xxxDO，xxx 即为数据表名。 - 2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。 - 3） 展示对象：xxxVO，xxx 一般为网页名称。 - 4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 (B) 领域模型命名规约 - 1） 数据对象：xxxDO，xxx 即为数据表名。 - 2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。 - 3） 展示对象：xxxVO，xxx 一般为网页名称。 - 4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO - 常量定义 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。 反例： String key = “Id#taobao_” + tradeId; cache.put(key, value); 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解。 说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2? 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。 如：缓存相关的常量放在类：CacheConsts下；系统配置相关的常量放在类：ConfigConsts 下。说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。 1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。 2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。 反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：类 A 中：public static final String YES = “yes”;类 B 中：public static final String YES = “y”;A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。 3） 子工程内部共享常量：即在当前子工程的 constant 目录下。 4） 包内共享常量：即在当前包下单独的 constant 目录下。 5） 类内共享常量：直接在类内部 private static final 定义。 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面 正例中的数字就是延伸信息，表示星期几。正例：public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6),SUNDAY(7);} 代码格式 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则： 1） 左大括号前不换行。 2） 左大括号后换行。 3） 右大括号前换行。 4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。 【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见第 5 条下方正例提示。 反例：if (空格 a == b 空格) 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。 【强制】任何二目、三目运算符的左右两边都需要加一个空格。说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。 【强制】缩进采用 4 个空格，禁止使用 tab 字符。说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。正例： （涉及 1-5 点） public static void main(String[] args) { // 缩进 4 个空格 String say = \"hello\"; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 if (flag == 0) { System.out.println(say); } // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) { System.out.println(\"world\"); // 右大括号前换行，右大括号后有 else，不用换行 } else { System.out.println(\"ok\"); // 在右大括号后直接结束，则必须换行 } } 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则： 1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。 2） 运算符与下文一起换行。 3） 方法调用的点符号与下文一起换行。 4） 在多个参数超长，在逗号后换行。 5） 在括号前不要换行，见反例。 正例： StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行 sb.append(\"zi\").append(\"xin\")... .append(\"huang\")... .append(\"huang\")... .append(\"huang\"); 反例： StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，不要在括号前换行 sb.append(\"zi\").append(\"xin\")...append (\"huang\"); //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行 method(args1, args2, args3, ... , argsX); 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。正例：下例中实参的”a”,后边必须要有一个空格。 method(“a”, “b”, “c”); 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。正例：int a = 3;long b = 4L;float c = 5F;StringBuffer sb = new StringBuffer();说明：增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。说明：没有必要插入多个空行进行隔开。 OOP 规约 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。 【强制】所有的覆写方法，必须加@Override 注解。说明：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程） 正例：public User getUsers(String type, Integer… ids) {…} 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。 【强制】不能使用过时的类或方法。说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。 【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 正例： “test”.equals(object);反例： object.equals(“test”); 说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。 关于基本数据类型与包装数据类型的使用标准如下： 1） 【强制】所有的 POJO 类属性必须使用包装数据类型。 2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。 3） 【推荐】所有的局部变量使用基本数据类型。 说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE 问题，或者入库检查，都由使用者来保证。 正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。反例：比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。 【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。 反例：POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。说明：String str = “a,b,c,,”;String[] ary = str.split(“,”);//预期大于 3，结果是 3System.out.println(ary.length); 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法。说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。 反例： public Integer getData() { if (true) { return this.data + 100; } else { return this.data - 100; } } 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。 说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。 反例： String str = \"start\"; for (int i = 0; i &lt; 100; i++) { str = str + \"hello\"; } 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字： 1） 不允许被继承的类，如：String 类。 2） 不允许修改引用的域对象，如：POJO 类的域变量。 3） 不允许被重写的方法，如：POJO 类的 setter 方法。 4） 不允许运行过程中重新赋值的局部变量。 5） 避免上下文重复使用一个变量，使用 final描述可以强制重新定义一个变量，方便更好地进行重构。 【推荐】慎用 Object 的 clone 方法来拷贝对象。说明：对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。 【推荐】类成员与方法访问控制从严： 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。 工具类不允许有 public 或 default 构造方法。 类非 static 成员变量并且与子类共享，必须是 protected。 类非 static 成员变量并且仅在本类使用，必须是 private。 类 static 成员变量如果仅在本类使用，必须是 private。 若是 static 成员变量，必须考虑是否为 final。 类成员方法只供类内部调用，必须是 private。 类成员方法只对继承类公开，那么限制为 protected。 说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。 【思考】 如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 方法，或者 一个 public的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。 集合处理 【强制】关于 hashCode 和 equals 的处理，遵循如下规则： 只要重写 equals，就必须重写 hashCode。 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。 说明：String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。 【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ; 说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。 【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生 ConcurrentModificationException 异常。 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。 说明：使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。 ==正例==： List&lt;String> list = new ArrayList&lt;String>(2); list.add(\"guan\"); list.add(\"bao\"); String[] array = new String[list.size()]; array = list.toArray(array); ==反例==： 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误。 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。说明：asList 的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。 String[] str = new String[] { \"a\", \"b\" }; List list = Arrays.asList(str); //第一种情况：list.add(\"c\"); 运行时异常。 //第二种情况：str[0] = \"gujin\"; 那么 list.get(0)也会随之修改。 【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法，而&lt;? super T&gt;不能使用 get 方法，做为接口调用赋值时易出错。说明：扩展说一下 PECS(Producer Extends Consumer Super)原则： 频繁往外读取内容的，适合用上界 Extends。 经常往里插入的，适合用下界 Super。 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。 正例： Iterator&lt;String> it = a.iterator(); while (it.hasNext()) { String temp = it.next(); if (删除元素的条件) { it.remove(); } } 反例： List&lt;String> a = new ArrayList&lt;String>(); a.add(\"1\"); a.add(\"2\"); for (String temp : a) { if (\"1\".equals(temp)) { a.remove(temp); } } 说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？ 【强制】 在 JDK7 版本及以上，Comparator 要满足如下三个条件，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。 说明： 1） x，y 的比较结果和 y，x 的比较结果相反。 2） x&gt;y，y&gt;z，则 x&gt;z。 3） x=y，则 x，z 比较结果和 y，z 比较结果相同。 反例：下例中没有处理相等的情况，实际使用中可能会出现异常： new Comparator&lt;Student>() { @Override public int compare(Student o1, Student o2) { return o1.getId() > o2.getId() ? 1 : -1; } }; 【推荐】集合初始化时，指定集合初始值大小。 说明：HashMap 使用 HashMap(int initialCapacity) 初始化 正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loaderfactor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16。 反例：HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。 正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：集合类 Key Value Super 说明Hashtable 不允许为 null 不允许为 null Dictionary 线程安全ConcurrentHashMap 不允许为 null 不允许为 null AbstractMap 分段锁技术TreeMap 不允许为 null 允许为 null AbstractMap 线程不安全HashMap 允许为 null 允许为 null AbstractMap 线程不安全反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常。 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是order/sort。 【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、去重操作。 并发处理 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。说明：资源驱动类、工具类、单例工厂类都需要注意。 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 正例： public class TimerTaskThread extends Thread { public TimerTaskThread() { super.setName(\"TimerTaskThread\"); ... } 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors 返回的线程池对象的弊端如下：1）FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。2）CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类。 正例：注意线程安全，使用 DateUtils。亦推荐如下处理： private static final ThreadLocal&lt;DateFormat> df = new ThreadLocal&lt;DateFormat>() { @Override protected DateFormat initialValue() { return new SimpleDateFormat(\"yyyy-MM-dd\"); } }; &gt; 说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar， &gt; DateTimeFormatter代替Simpledateformatter，官方给出的解释：simple beautiful strong &gt; immutable thread-safe。 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。 说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。 【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 await 方法，直到超时才返回结果。 说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个实例。 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。反例： class Foo { private Helper helper = null; public Helper getHelper() { if (helper == null) synchronized(this) { if (helper == null) helper = new Helper(); } return helper; } // other functions and members... } 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。 【参考】 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。 【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。 控制语句 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。 【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements; 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：if (condition) {…return obj;}// 接着写 else 的业务逻辑代码;说明：如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。正例：逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。卫语句示例如下： public void today() { if (isBusy()) { System.out.println(“change time.”); return; } if (isFree()) { System.out.println(“go to travel.”); return; } System.out.println(“stay at home to learn Alibaba Java Coding Guideline.”); return; } 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。说明：很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？正例： //伪代码如下 final boolean existed = (file.open(fileName, \"w\") != null) &amp;&amp; (...) || (...); if (existed) { ... } 反例： if ((file.open(fileName, \"w\") != null) &amp;&amp; (...) || (...)) { ... } 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。 【参考】下列情形，需要进行参数校验： 1） 调用频次低的方法。 2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。 3） 需要极高稳定性和可用性的方法。 4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。 5） 敏感权限入口。 【参考】下列情形，不需要进行参数校验： 1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。 3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。 注释规约 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容/格式，不得使用//xxx 方式。 说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明：对子类的实现要求，或者调用注意事项，请一并说明。 【强制】所有的类都必须添加创建者和创建日期。 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/ /注释，注意与代码对齐。 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。 反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。 说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。 【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。 说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没 有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。 【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。 反例： &gt; // put elephant into fridge &gt; put(elephant, fridge); &gt; 方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语 &gt; 义清晰的代码不需要额外的注释。 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。 1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。 2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况 后记以上内容均录自阿里java开发手册，希望自己在代码规范上有一个提升，不仅仅是这个专业领域，对于生活也是这样。 2017-6-21 今天夏至啊啊","categories":[{"name":"java基础","slug":"java基础","permalink":"http://blog.cuteximi.com/categories/java基础/"}],"tags":[{"name":"java规范","slug":"java规范","permalink":"http://blog.cuteximi.com/tags/java规范/"}]},{"title":"Hello,win10","slug":"win10","date":"2017-06-04T08:10:46.000Z","updated":"2017-06-22T12:37:35.000Z","comments":true,"path":"win10/","link":"","permalink":"http://blog.cuteximi.com/win10/","excerpt":"前言 作为win7的重度使用者的我，当win10盛行的时候，还是继续使用win7,一方面不喜欢win10的风格，另一方面自己也懒，前一段时间的勒索病毒袭击，使得自己开始改变想法，决定使用win10.","text":"前言 作为win7的重度使用者的我，当win10盛行的时候，还是继续使用win7,一方面不喜欢win10的风格，另一方面自己也懒，前一段时间的勒索病毒袭击，使得自己开始改变想法，决定使用win10.我选择的是从win7升级到win10专业版，在微软中国的下载官方升级助手win10下载 ，剩下的步骤都很简单，一路next.我折腾了两次，第一次升级完成之后，一直蓝屏，当时不确定是什么原因，无奈又回退到win7,然后又尝试了电脑管家的自助升级，检测的时候发现显卡驱动不支持升级到win10…..，于是下了一个驱动管理工具，检测本机的驱动，安装最新的驱动，果然，再一次尝试升级win10，啦啦啦啦啦，中午吃饭空隙，在宿舍睡了一觉，回到教室，安装完毕。心情….不可描述哇！ 好激动！！！！ 当我开始愉快的设置各种东西的时候—-哎？不对，触摸板不好使了，之前在win7上使用的手势都没了，估计是驱动坏掉了，好吧，我去Dell官网下载一个最新版的，安装的时候，有问题（之前的没卸载干净导致的），win+R:输入regedit;找到注册表，删掉，重新安装，完美解决… 写在后面 菜鸟一枚，要学习的东西太多了，加油喽！勉励自己：这个世界上面有困难，难的是坚持下去。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://blog.cuteximi.com/categories/随笔/"}],"tags":[{"name":"win10","slug":"win10","permalink":"http://blog.cuteximi.com/tags/win10/"}]},{"title":"springmvc填坑（1）","slug":"springmvc填坑（1）","date":"2017-05-26T14:15:48.000Z","updated":"2017-06-22T12:38:50.000Z","comments":true,"path":"springmvc填坑（1）/","link":"","permalink":"http://blog.cuteximi.com/springmvc填坑（1）/","excerpt":"","text":"版本的问题好坑啊！ 在整合springmvc时，要返回json格式的数据出现问题！！！好气啊 先看下错误： org.springframework.web.util.NestedServletException:Handler dispatch failed; nested exception is java.lang.NoSuchMethodError 一般都是通过 @ResponseBody 返回json数据的。还采用jackson与springmvc的配置话，需要选择合适的版本。jackson2.7不兼容最新的springmvc4.2.4官网描述： Work on Jackson 2.7 started in August 2015 and completed in early January 2016.We need to revise our type variable exposure (SPR-13728) for proper Jackson 2.7 support in Spring Framework 4.3 and should also evaluate other changes that are worth adapting to. ==所以要想执行成功需要选择jackson2.6版本才能和springmvc4.3.0正确使用。==","categories":[{"name":"编程","slug":"编程","permalink":"http://blog.cuteximi.com/categories/编程/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://blog.cuteximi.com/tags/SpringMVC/"}]},{"title":"ET04","slug":"ET04","date":"2017-05-21T13:50:06.000Z","updated":"2017-06-22T12:39:25.000Z","comments":true,"path":"ET04/","link":"","permalink":"http://blog.cuteximi.com/ET04/","excerpt":"","text":"英语很重要 一点都没错DayFour1. I insit on writing a blog evryday. 2. You are great. 3. I want to be the first.","categories":[{"name":"英语","slug":"英语","permalink":"http://blog.cuteximi.com/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://blog.cuteximi.com/tags/英语/"}]},{"title":"ET03","slug":"ET03","date":"2017-05-20T14:01:17.000Z","updated":"2017-06-22T12:40:26.000Z","comments":true,"path":"ET03/","link":"","permalink":"http://blog.cuteximi.com/ET03/","excerpt":"","text":"英语很重要 一点都没错DayThree1. To make each day count. 2. All life is a game of luck.","categories":[{"name":"英语","slug":"英语","permalink":"http://blog.cuteximi.com/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://blog.cuteximi.com/tags/英语/"}]},{"title":"ET02","slug":"ET02","date":"2017-05-19T14:08:10.000Z","updated":"2017-06-22T12:40:46.000Z","comments":true,"path":"ET02/","link":"","permalink":"http://blog.cuteximi.com/ET02/","excerpt":"英语很重要 一点都没错DayTwo早上六点半起来学一点英语表达：1. I wanna be your … 2. I just can’t help thinking…","text":"英语很重要 一点都没错DayTwo早上六点半起来学一点英语表达：1. I wanna be your … 2. I just can’t help thinking… 永远的朋友 “A friend walk in when the rest of the world walks out.” “别人都走开的时候，朋友仍与你在一起。” Sometimes in life, 有时候在生活中， You find a special friend; 你会找到一个特别的朋友; Someone who changes your life just by being part of it. 他只是你生活中的一部分内容，却能改变你整个的生活。 Someone who makes you laugh until you can’t stop; 他会把你逗得开怀大笑； Someone who makes you believe that there really is good in the world. 他会让你相信人间有真情。 Someone who convinces you that there really is an unlocked door just waiting for you to open it. 他会让你确信，真的有一扇不加锁的门，在等待着你去开启。 This is Forever Friendship. 这就是永远的友谊。 when you’re down, 当你失意， and the world seems dark and empty, 当世界变得黯淡与空虚， Your forever friend lifts you up in spirits and makes that dark and empty world suddenly seem bright and full. 你真正的朋友会让你振作起来，原本黯淡、空虚的世界顿时变得明亮和充实。 Your forever friend gets you through the hard times, the sad times, and the confused times. 你真正的朋友会与你一同度过困难、伤心和烦恼的时刻。 If you turn and walk away, 你转身走开时， Your forever friend follows, 真正的朋友会紧紧相随， If you lose you way, 你迷失方向时， Your forever friend guides you and cheers you on. 真正的朋友会引导你，鼓励你。 Your forever friend holds your hand and tells you that everything is going to be okay. 真正的朋友会握着你的手，告诉你一切都会好起来的。 And if you find such a friend, 如果你找到了这样的朋友， You feel happy and complete, 你会快乐，觉得人生完整， Because you need not worry, 因为你无需再忧虑。 Your have a forever friend for life, 你拥有了一个真正的朋友， And forever has no end. 永永远远，永无止境。","categories":[{"name":"英语","slug":"英语","permalink":"http://blog.cuteximi.com/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://blog.cuteximi.com/tags/英语/"}]},{"title":"ET01","slug":"ET01","date":"2017-05-18T14:05:41.000Z","updated":"2017-06-22T12:39:51.000Z","comments":true,"path":"ET01/","link":"","permalink":"http://blog.cuteximi.com/ET01/","excerpt":"英语很重要 一点都没错DayOne早上六点半起来学一点英语表达：1. You’ve been good to me my whole life. 2. Sentence to be carried out immediately. 3. ‘Trust me’ means absolutely zero inside those walls. 4. Take additional time to consider your response.","text":"英语很重要 一点都没错DayOne早上六点半起来学一点英语表达：1. You’ve been good to me my whole life. 2. Sentence to be carried out immediately. 3. ‘Trust me’ means absolutely zero inside those walls. 4. Take additional time to consider your response. 每天会定时按照这个模式来更新自己学到的英语（准确的说是看到的！！！） 1.I see． 我明白了. 2.I quit!我不干了! 3.Let go!放手! 4.Me too． 我也是. 5.My god!天哪! 6.No way!不行! 7.Come on． 来吧(赶快) 8.Hold on． 等一等. 9.I agree.我同意. 10.Not bad． 还不错. 11.Not yet． 还没. 12.See you． 再见. 13.Shut up!闭嘴! 14.So long． 再见. 14.So long． 再见. 15.Why not?好呀!(为什么不呢?) 16.Allow me． 让我来. 17.Be quiet!安静点! 18.Cheer up!振作起来! 19.Good job!做得好! 20.Have fun!玩得开心! 21.How much?多少钱? 22.I’m full． 我饱了. 23.I’m home． 我回来了. 24.I’m lost． 我迷路了. 25.My treat． 我请客. 26.So do I． 我也一样. 27.This way.这边请. 28.After you． 您先. 29.Bless you!祝福你! 30.Follow me． 跟我来. 31.Forget it!休想!(算了!) 32.Good luck!祝好运! 33.I decline!我拒绝! 34.I promise． 我保证. 35.Of course!当然了! 36.Slow down!慢点! 37.Take care!保重! 38.They hurt． (伤口)疼. 39.Try again． 再试试. 40.Watch out!当心. 41.What’s up?有什么事吗? 42.Be careful!注意! 43.Bottoms up!干杯(见底)! 44.Don’t move!不许动! 45.Guess what?猜猜看? 46.I doubt it 我怀疑. 47.I think so． 我也这么想. 48.I’m single． 我是单身贵族. 49.Keep it up!坚持下去! 50.Let me see．让我想想. 51.Never mind．不要紧. 52.No problem!没问题! 53.That’s all!就这样! 54.Time is up． 时间快到了. 55.What’s new?有什么新鲜事吗? 56.Count me on 算上我. 57.Don’t worry． 别担心. 58.Feel better?好点了吗? 59.I love you!我爱你! 60.I’m his fan.我是他的影迷. 61.Is it yours?这是你的吗? 62.That’s neat． 这很好. 63.Are you sure?你肯定吗? 64.Do l have to 非做不可吗? 65.He is my age． 他和我同岁. 66.Here you are． 给你. 67.No one knows .没有人知道. 68.Take it easy． 别紧张. 69.What a pity!太遗憾了! 70.Any thing else?还要别的吗? 71.To be careful!一定要小心! 72.Do me a favor?帮个忙,好吗? 73.Help yourself． 别客气. 74.I’m on a diet． 我在节食. 75.Keep in Touch． 保持联络. 76.Time is money． 时间就是金钱. 77.Who’s calling?是哪一位? 78.You did right． 你做得对. 79.You set me up!你出卖我! 80.Can I help you?我能帮你吗? 81.Enjoy yourself!祝你玩得开心! 82.Excuse me,Sir． 先生,对不起. 83.Give me a hand!帮帮我! 84.How’s it going?怎么样? 85.I have no idea． 我没有头绪. 86.I just made it!我做到了! 87.I’ll see to it 我会留意的. 88.I’m in a hurry!我在赶时间! 89.It’s her field． 这是她的本行. 90.It’s up to you． 由你决定. 91.Just wonderful!简直太棒了! 92.What about you?你呢? 93.You owe me one．你欠我一个人情. 94.You’re welcome． 不客气. 95.Any day will do． 哪一天都行. 96.Are you kidding?你在开玩笑吧! 97.Congratulations!祝贺你! 98.T can’t help it.我情不自禁. 99.I don’t mean it.我不是故意的. 100.I’ll fix you up． 我会帮你打点的. 101.It sounds great!． 听起来很不错. 102.It’s a fine day.今天是个好天. 103.So far,so good． 目前还不错. 104.What time is it?几点了? 105.You can make it!你能做到! 106.Control yourself!克制一下! 107.He came by train． 他乘火车来. 108.He is ill in bed． 他卧病在床. 109.He lacks courage． 他缺乏勇气. 110.How’s everything?一切还好吧? 111.I have no choice． 我别无选择. 112.I like ice-cream． 我喜欢吃冰淇淋. 113.I love this game． 我钟爱这项运动. 114.I’ll try my best． 我尽力而为. 115.I’m On your side． 我全力支持你. 116.Long time no see!好久不见! 117.No pain,no gain． 不劳无获. 118.Well,it depends.噢,这得看情况. 119.We’re all for it． 我们全都同意. 120.What a good deal!真便宜! 121.What should I do?我该怎么办? 122.You asked for it!你自讨苦吃!","categories":[{"name":"英语","slug":"英语","permalink":"http://blog.cuteximi.com/categories/英语/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://blog.cuteximi.com/tags/英语/"}]},{"title":"npm使用","slug":"npm使用","date":"2017-05-12T01:22:29.000Z","updated":"2017-06-22T12:38:19.000Z","comments":true,"path":"npm使用/","link":"","permalink":"http://blog.cuteximi.com/npm使用/","excerpt":"NPM常用命令NPM是什么？ NPM的全称是Node Package Manager，是随同NodeJS一起安装的包管理和分发工具，它很方便让JavaScript开发者下载、安装、上传以及管理已经 安装的包。","text":"NPM常用命令NPM是什么？ NPM的全称是Node Package Manager，是随同NodeJS一起安装的包管理和分发工具，它很方便让JavaScript开发者下载、安装、上传以及管理已经 安装的包。 安装模块1.npm install packageName 安装nodejs的依赖包例如npm install express-generator 就会默认安装express的最新版本，也可以通过在后面加版本号的方式安装指定版本 2.npm install packageName -g 将包安装到全局环境中但是代码中，直接通过require()的方式是没有办法调用全局安装的包的。全局的安装是供命令行使用的 可以设置全局目录 npm set config prefix “目录路径” ,通过 npm config get prefix 来获取当前设置的目录。 3.npm install packageName –save 安装的同时，将信息写入package.json中项目路径中如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包 卸载模块1.npm uninstall packageName 卸载安装的包 NPM设置npm config set proxy “” http://proxy.tencent.com:8080 设置代理 npm config set registry “” https://registry.npm.taobao.org 设置npm的镜像地址由于npm的服务器再国外，所以访问非常的慢，我们可以将其设置在国内的镜像，例如，淘宝","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.cuteximi.com/categories/工具/"}],"tags":[{"name":"NPM","slug":"NPM","permalink":"http://blog.cuteximi.com/tags/NPM/"}]},{"title":"java代码优化","slug":"java代码优化","date":"2017-05-11T11:46:39.000Z","updated":"2017-05-11T11:54:36.000Z","comments":true,"path":"java代码优化/","link":"","permalink":"http://blog.cuteximi.com/java代码优化/","excerpt":"前言 代码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。 代码优化的目标是 减小代码的体积 提高代码运行的效率","text":"前言 代码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。 代码优化的目标是 减小代码的体积 提高代码运行的效率 代码优化细节 1、尽量指定类、方法的final修饰符带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。 2、尽量重用对象特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。 3、尽可能使用局部变量调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 4、及时关闭流Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。 5、尽量减少对变量的重复计算明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作： for (int i = 0; i &lt; list.size(); i++) {...} //建议替换为 for (int i = 0, int length = list.size(); i &lt; length; i++) {...} 这样，在list.size()很大的时候，就减少了很多的消耗 6、尽量采用懒加载的策略，即在需要的时候才创建例如： String str = \"aaa\"; if (i == 1){ list.add(str); } //建议替换为 if (i == 1){ String str = \"aaa\"; list.add(str); } 7、慎用异常异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。 8、不要在循环中使用try…catch…，应该把其放在最外层除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了 9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例： （1）StringBuilder() // 默认分配16个字符的空间 （2）StringBuilder(int size) // 默认分配size个字符的空间 （3）StringBuilder(String str) // 默认分配16个字符+str.length()个字符空间 可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么： （1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间 （2）把原来的4096个字符拷贝到新的的字符数组中去 这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。 10、当复制大量数据时，使用System.arraycopy()命令11、乘法和除法使用移位操作例如： for (val = 0; val &lt; 100000; val += 5){ a = val * 8; b = val / 2; } //用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： for (val = 0; val &lt; 100000; val += 5){ a = val &lt;&lt; 3; b = val >> 1; } 移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。 12、循环内不要不断创建对象引用例如： for (int i = 1; i &lt;= count; i++) { Object obj = new Object(); } 这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为： Object obj = null;for (int i = 0; i &lt;= count; i++) { obj = new Object(); }这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。 13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销15、不要将数组声明为public static final因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变 16、尽量在合适的场合使用单例使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： （1）控制资源的使用，通过线程同步来控制资源的并发访问 （2）控制实例的产生，以达到节约资源的目的 （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 17、尽量避免随意使用静态变量要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如： public class A { private static B b = new B(); } 此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止 18、及时清除不再需要的会话为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。 19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断： if (list instanceof RandomAccess){ for (int i = 0; i &lt; list.size(); i++){ } }else{ Iterator&lt;?> iterator = list.iterable(); while (iterator.hasNext()){ iterator.next() } } foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。 20、使用同步代码块替代同步方法这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。 21、将常量声明为static final，并以大写命名这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量 22、不要创建一些不使用的对象，不要导入一些不使用的类这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容 23、程序运行过程中避免使用反射关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。 24、使用数据库连接池和线程池这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程 25、使用带缓冲的输入输出流进行IO操作带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率 26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个，理解ArrayList和LinkedList的原理就知道了 27、不要让public方法中有太多的形参public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处： 1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合 2、参数太多势必导致方法调用的出错概率增加 至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参 28、字符串变量和字符串常量equals的时候将字符串常量写在前面这是一个比较常见的小技巧了，如果有以下代码： String str = \"123\"; if (str.equals(\"123\")) { ... } 建议修改为： String str = \"123\"; if (\"123\".equals(str)) { ... } 这么做主要是可以避免空指针异常 29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。 在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码： int i = 2; if (i == 1) { ... }else{ ... } C/C++判断”i==1″不成立，所以以0表示，即false。但是如果： int i = 2;if (i = 1) { … }else{ … }万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为： int i = 2;if (1 == i) { … }else{ … }这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。 但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。 30、不要对数组使用toString()方法看一下对数组使用toString()打印出来的是什么： public static void main(String[] args){ int[] is = new int[]{1, 2, 3}; System.out.println(is.toString()); } 结果是： [I@18a992f本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString()方法。 31、不要对超出范围的基本数据类型做向下强制转型这绝不会得到想要的结果： public static void main(String[] args){ long l = 12345678901234L; int i = (int)l; System.out.println(i); } 我们可能期望得到其中的某几位，但是结果却是： 1942892530 解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是： 0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010 一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是： 0111 0011 1100 1110 0010 1111 1111 0010 这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论： 1、整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f = 3.5f” 2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int 32、公用的集合类中不使用的数据一定要及时remove掉 如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。 33、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试： public static void main(String[] args) { int loopTime = 50000; Integer i = 0; long startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++){ String str = String.valueOf(i); } System.out.println(&quot;String.valueOf()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++){ String str = i.toString(); } System.out.println(&quot;Integer.toString()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++){ String str = i + &quot;&quot;; } System.out.println(&quot;i + \\&quot;\\&quot;：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); } 运行结果为： String.valueOf()：11ms Integer.toString()：5ms i + “”：25ms所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单： 1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断 2、Integer.toString()方法就不说了，直接调用了 3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串 三者对比下来，明显是2最快、1次之、3最慢 34、使用最有效率的方式去遍历Map遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是： public static void main(String[] args){ HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); hm.put(&quot;111&quot;, &quot;222&quot;); Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet(); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); while (iter.hasNext()){ Map.Entry&lt;String, String&gt; entry = iter.next(); System.out.println(entry.getKey() + &quot;\\t&quot; + entry.getValue()); } } 如果你只是想遍历一下这个Map的key值，那用”Set keySet = hm.keySet();”会比较合适一些 35、对资源的close()建议分开操作意思是，比如我有这么一段代码： try{ XXX.close(); YYY.close(); }catch (Exception e) { ... } 建议修改为： try{ XXX.close(); }catch (Exception e) { ... } try{ YYY.close(); }catch (Exception e) { ... } 虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉。 参考文章点这里","categories":[{"name":"java基础","slug":"java基础","permalink":"http://blog.cuteximi.com/categories/java基础/"}],"tags":[{"name":"代码优化","slug":"代码优化","permalink":"http://blog.cuteximi.com/tags/代码优化/"}]},{"title":"coding01","slug":"coding01","date":"2017-05-05T13:08:05.000Z","updated":"2017-05-05T13:52:32.000Z","comments":true,"path":"coding01/","link":"","permalink":"http://blog.cuteximi.com/coding01/","excerpt":"前言在coding过程中遇到的问题： 1.IED的选择，从今天开始使用intellij Idea 2.在添加判断的时候 equals和==的区别","text":"前言在coding过程中遇到的问题： 1.IED的选择，从今天开始使用intellij Idea 2.在添加判断的时候 equals和==的区别 首先介绍一个intellij Idea 公认的java开发最好工具之一。当然最突出的功能是Debug 官网地址：IDEA 打开软件：很美观吧 软件的使用部分： setting:IDEA配置 plugins:插件管理 project defaults:项目配置 快捷键： equals和== 1.== 对于基本数据类型 使用==判断数值是否相等 对于引用类型的时候，例如String s = new String();此时s占一块内存空间，new String（）占一块空间；==比较的是，s中的数值就是对象占用的那块内存的的首地址 2.equals 比较两个对象的内容是否相等； equals方法是Object类的一个方法，每个java类都继承了该方法，所以呢，每个对象都具有这个方法 Object类定义的equals(Obejct)方法是直接使用“==”运算符实现比较两个对象的，所以在没有覆盖equals()的情况下，equals()和==一样 ,比较的是引用； hashCode 也是继承自Object类，返回对象在内存中地址转换成的int值，所有如果没有重写hashCode（）时，每个对象的返回的hashCode值是不相同 的； equals和hashCode的关系如下： x.equals(y)返回true,则x和y对应的hashCode（）返回值也相等； x.equals(y)返回false,则x和y对应的hashCode（）返回值可能相等，也可能不相等","categories":[{"name":"知识点","slug":"知识点","permalink":"http://blog.cuteximi.com/categories/知识点/"}],"tags":[{"name":"equals","slug":"equals","permalink":"http://blog.cuteximi.com/tags/equals/"}]},{"title":"面向对象三大特性","slug":"面向对象三大特性","date":"2017-05-02T13:08:18.000Z","updated":"2017-05-02T13:10:18.000Z","comments":true,"path":"面向对象三大特性/","link":"","permalink":"http://blog.cuteximi.com/面向对象三大特性/","excerpt":"面向对象三大特性 封装 继承 多态","text":"面向对象三大特性 封装 继承 多态 封装隐藏一切不对外公开的细节，使用者只能通过事先定义好的公共方法来访问数据，方便得多加入一些逻辑控制，限制对这些属性的不合理操作， 便于修改，增强可维护性。 权限修饰符 ==但是修饰类的时候 只可能是public和defaultpublic修饰类 可以在任何地方被访问default修饰类 只能被一个包里的类访== javabean是一种java语音写的可重用组件 有如下标准： 公共类 有一个无参的构造器 有属性，且提供了相应的getter,setter。 继承代码重用 使得类之间有了关系，是多态的前提 重写： 方法名字，参数列表，返回值类型不变 权限修饰：子类不能低于父类的权限 重写和被重写的方法都是static或者都是非static 子类方法不能抛出比父类被重写方法更大的异常 重载：在一个类中，只看参数列表，==和返回值类型无关==。 多态一个事物的多个表现 在java中存在两种体现： 方法 的重写和重载 对象的多态性，抽象类和接口 Person p = new Student() 创建子类对象，赋给父类的引用 一个引用指向多个子类对象。 虚拟方法的调用 编译时，运行时","categories":[{"name":"java基础","slug":"java基础","permalink":"http://blog.cuteximi.com/categories/java基础/"}],"tags":[]},{"title":"学习计划","slug":"学习计划","date":"2017-05-02T09:33:50.000Z","updated":"2017-05-02T10:28:27.000Z","comments":true,"path":"学习计划/","link":"","permalink":"http://blog.cuteximi.com/学习计划/","excerpt":"","text":"java需要学习的东西：","categories":[{"name":"大三计划","slug":"大三计划","permalink":"http://blog.cuteximi.com/categories/大三计划/"}],"tags":[]},{"title":"newStart","slug":"newStart","date":"2017-05-01T12:09:41.000Z","updated":"2017-05-11T11:55:41.000Z","comments":true,"path":"newStart/","link":"","permalink":"http://blog.cuteximi.com/newStart/","excerpt":"","text":"新的开始 忘掉从前2017年五月二号就要搬去实训基地了。加油，踏踏实实学习吧。","categories":[{"name":"转折","slug":"转折","permalink":"http://blog.cuteximi.com/categories/转折/"}],"tags":[]},{"title":"程序员要学的东西","slug":"程序员要学的东西","date":"2017-04-06T13:00:34.000Z","updated":"2017-04-06T13:15:34.000Z","comments":true,"path":"程序员要学的东西/","link":"","permalink":"http://blog.cuteximi.com/程序员要学的东西/","excerpt":"拿java来说，首先学习这门语言的语法，然后再是它的类库，学完类库还要学习框架；","text":"拿java来说，首先学习这门语言的语法，然后再是它的类库，学完类库还要学习框架； 但是上面这些远远是不够的： 数据结构和算法必须学得学，所以《算法》，《大话数据结构》，《图解数据结构》，《算法导论》等等 设计模式； 面对对象分析和设计也是很重要的； 敏捷开发，DevOps,单元测试，持续继承，TDD,结对编程； 数据库，sql,表的设计，范式，锁，隔离级别 深入一点，调优，在架构层面还得了解分库，分表，备份，读写分离； 除了关系数据库，NoSQL在互联网时代很流行。 缓存 memcached,redis 操作系统也得学 这样才能理解进程/线程，通信，异步，同步，阻塞和给阻塞。sekect/epoll 虚拟内存和文件系统 Linux的基本命令 深入java虚拟机 tomcat等","categories":[{"name":"编程","slug":"编程","permalink":"http://blog.cuteximi.com/categories/编程/"}],"tags":[{"name":"思路","slug":"思路","permalink":"http://blog.cuteximi.com/tags/思路/"}]},{"title":"爱她就不会争论输赢","slug":"爱她就不会争论输赢","date":"2017-03-28T14:11:27.000Z","updated":"2017-03-28T14:14:22.000Z","comments":true,"path":"爱她就不会争论输赢/","link":"","permalink":"http://blog.cuteximi.com/爱她就不会争论输赢/","excerpt":"爱她就不会争论输赢 有句话说的很对，“你爱的，你想的，你牵挂的最终都会输给对你好的。”女孩子最感动的还是对她好的人，会纵容她包容她，让她拥有绝对的安全感，也舍不得她生气难过的人。","text":"爱她就不会争论输赢 有句话说的很对，“你爱的，你想的，你牵挂的最终都会输给对你好的。”女孩子最感动的还是对她好的人，会纵容她包容她，让她拥有绝对的安全感，也舍不得她生气难过的人。ღ 大学里有一对让别人特别羡慕的情侣他们在一起两年了，但是感情还像第一次在一起时的那样热情高调。他们一起上课签到，一起吃饭聊天，好像一直都有说不完的话题一样，男孩子对女孩子也很好的，每天嘘寒问暖，我们都觉得他很体贴女孩子。 ✎那次出去聚餐，我们吃自助餐，他女朋友起身想去拿食物的时候，他按下她的手，说“我去吧，你坐着就行了。”他女朋友笑嘻嘻地说，“你要去？你知道我喜欢吃什么啊？”他说，“宝宝，我连自己喜欢吃的都没有记住，就只记住你喜欢吃的了。”无意间，又秀了我们在坐的单身狗一脸恩爱啊。 后来我们调侃他，说有了女朋友以后，越来越“妻奴”了，他却说，“在有了她之前，我怎样都行，但是和她在一起了之后，我心里想着的都是两个人的事情了，不能不多为她考虑着点。”他女朋友听了瞬间眼睛都红了，有被感动到了，别提他女朋友了，我们听了都忍不住想哭，他真的很爱他女朋友啊。 ✎女生真的很容易被细节感动到，因为他爱你，所以他会记住你喜欢的食物，喜欢看的电影，喜欢听的音乐，又会出其不意地将他记在心里的自然而然地展现出来。1 他对你的好，在他的一言一行里便表现了出来，举手投足之间显露出的全是宠溺和爱意。如果你感受到对方对你不好了，感受到明显的变化了，不管你做什么他都不愿意让步，无论如何总要辩论出一个输赢，那么很难说这个人是爱你的。 其实有时候简单的一个动作，一句话就会让她很感动，因为女生的内心真的很简单。 比如，平时他一本正经，不苟言笑的。但是对女朋友就即刻化身为话唠，叮嘱她要注意这个注意那个的，这才算得上是爱啊。如果一个男人爱你，他会把你当成他生命中永远的少女，你的一颦一笑，会牵引着他的心，他会尽最大的努力让你开心，让你感动。 ✎最容易让女生感动的标志有三个，要么怕她，要么宠她，要么疼她，但这所有的一切都要靠行动来表明。他可以大大方方的介绍你是他的女朋友，他不隐藏你的身份，不找冠冕堂皇的借口告诉你，什么狗屁恋爱只是两个人的事。他愿意带着你去参加各种私下里的饭局儿，酒局儿，桌游局儿，别人问他有没有另一半时他不会犹豫。 他会视你如宝贝，他会记得你们的每一个纪念日，面对着你，他巴不得把所有最好的东西都给你。你不管有多少的小脾气，在他眼里都是可爱的小任性，你无论有多么幼稚和冲动，在他心里都是动容的小心思。 他们都说女孩子是没有爱情的，谁对她好她就跟谁跑了。所以爱她，就应该要让她感动，值此她一直都会跟着你，不会离开。","categories":[{"name":"生活","slug":"生活","permalink":"http://blog.cuteximi.com/categories/生活/"}],"tags":[{"name":"love","slug":"love","permalink":"http://blog.cuteximi.com/tags/love/"}]},{"title":"music","slug":"music","date":"2017-03-28T13:37:59.000Z","updated":"2017-03-28T14:09:28.000Z","comments":true,"path":"music/","link":"","permalink":"http://blog.cuteximi.com/music/","excerpt":"hexo中加入音乐博主原文入口在这 自己按照这个方法试一试效果。","text":"hexo中加入音乐博主原文入口在这 自己按照这个方法试一试效果。小插曲：在使用命令行窗口的过程中： git 版本控制工具，支持该工具的网站有Github、BitBucket、Gitorious、国内的osChina仓库、csdn仓库等等。 shell 是Linux、unix系统的外壳，也可以理解为命令行，就是你输入并执行命令的地方，git通过命令行和图形界面两种方式使用shell。 bash 是shell的一种，最常用的shell之一。 git Bash 方便你在windows下使用git命令的模拟终端（windows自带的cmd功能太弱）linux、unix可以直接使用git。 git shell 它是安装了git的shell，bash是一种shell。 废话少说，直接上效果例子：（ps:不用插件就可以实现） &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=347597&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;","categories":[{"name":"生活","slug":"生活","permalink":"http://blog.cuteximi.com/categories/生活/"}],"tags":[{"name":"music","slug":"music","permalink":"http://blog.cuteximi.com/tags/music/"}]},{"title":"maven","slug":"maven","date":"2017-03-27T14:47:46.000Z","updated":"2017-03-27T14:58:21.000Z","comments":true,"path":"maven/","link":"","permalink":"http://blog.cuteximi.com/maven/","excerpt":"maven介绍==maven是基于项目对象模型(POM),可以通过一小段的描述信息来管理项目的构建，报告和文档的软件项目管理工具。==","text":"maven介绍==maven是基于项目对象模型(POM),可以通过一小段的描述信息来管理项目的构建，报告和文档的软件项目管理工具。==默认的项目结构如下 目录 结构 ${basedir} 存放pom.xml文件和其他子目录 ${basedir}/src/main/java 项目的java源代码 ${basedir}/src/main/java/resource 项目用到的资源 ${basedir}/src/test/java 项目的测试类 ${basedir}/src/test/java/resource 测试用到的资源 一个maven项目默认会生成JAR文件，另外，编译好的class文件会保存在basedir/target/classes里面。 maven下载与安装下载安装略。 配置1.setting.xml配置本地的仓库 &lt;localRepository&gt;D:\\maven\\apache-maven-3.3.9/mvn/mvnrepository&lt;/localRepository&gt; 2.将maven配置到eclipse 下载插件eclipse-maven3-plugin，安装之后： Installations里面add本地下载的maven 修改User Settings，对应的Local Repository也会变成你之前设置的那个。 maven常用的命令Maven常用命令： 创建Maven的普通java项目：mvn archetype:create -DgroupId=packageName -DartifactId=projectName 创建Maven的Web项目：mvn archetype:create -DgroupId=packageName -DartifactId=webappName-DarchetypeArtifactId=maven-archetype-webapp 编译源代码： mvn compile 编译测试代码：mvn test-compile 运行测试：mvn test 产生site：mvn site 打包：mvn package 在本地Repository中安装jar：mvn install 清除产生的项目：mvn clean 生成eclipse项目：mvn eclipse:eclipse 生成idea项目：mvn idea:idea 组合使用goal命令，如只打包不测试：mvn -Dtest package 编译测试的内容：mvn test-compile 只打jar包: mvn jar:jar 只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile( -skipping 的灵活运用，当然也可以用于其他组合命令) 清除eclipse的一些系统设置:mvn eclipse:clean","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.cuteximi.com/categories/工具/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://blog.cuteximi.com/tags/maven/"}]},{"title":"home","slug":"home","date":"2017-03-26T14:08:12.000Z","updated":"2017-03-26T14:11:34.000Z","comments":true,"path":"home/","link":"","permalink":"http://blog.cuteximi.com/home/","excerpt":"","text":"最近的自己有点浮躁，希望自己静下新来学习东西，加油。 未来是你的，你是最棒的。","categories":[{"name":"生活","slug":"生活","permalink":"http://blog.cuteximi.com/categories/生活/"}],"tags":[]},{"title":"mybatis入门","slug":"mybatis入门","date":"2017-03-21T00:08:30.000Z","updated":"2017-03-21T07:49:43.000Z","comments":true,"path":"mybatis入门/","link":"","permalink":"http://blog.cuteximi.com/mybatis入门/","excerpt":"学习Mybatis的过程（一） 什么是Mybatis 原生jdbc开发的总结 Mybatis框架的流程图 Mybatis的学习思路 1.什么是MybatisMybatis是一个持久层的框架，开源的的，是Apache下的一个顶级项目，现在这个项目托管到github里面了。点击传送门查看这个开源项目。","text":"学习Mybatis的过程（一） 什么是Mybatis 原生jdbc开发的总结 Mybatis框架的流程图 Mybatis的学习思路 1.什么是MybatisMybatis是一个持久层的框架，开源的的，是Apache下的一个顶级项目，现在这个项目托管到github里面了。点击传送门查看这个开源项目。Mybatis让程序员把主要的精力放在sql上，自己编写sql,根据需要去灵活的编写。 官网的解释： MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 2.原生jdbc开发的总结先看一段代码： Class Test{ public static void main(String[] args) { //数据库连接 Connection connection = null; //预编译的Statement，使用预编译的Statement提高数据库性能 PreparedStatement preparedStatement = null; //结果 集 ResultSet resultSet = null; try { //加载数据库驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //通过驱动管理类获取数据库链接 connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\", \"root\", \"mysql\"); //定义sql语句 ?表示占位符 String sql = \"select * from user where username = ?\"; //获取预处理statement preparedStatement = connection.prepareStatement(sql); //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, \"王五\"); //向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //遍历查询结果集 while(resultSet.next()){ System.out.println(resultSet.getString(\"id\")+\" \"+resultSet.getString(\"username\")); } } catch (Exception e) { e.printStackTrace(); }finally{ //释放资源 if(resultSet!=null){ try { resultSet.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } if(preparedStatement!=null){ try { preparedStatement.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } if(connection!=null){ try { connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } 单独使用jdbc开发存在的问题：主要是数据库连接和硬编码的问题 1、数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响 数据库性能。设想：使用数据库连接池管理数据库连接。 2、将sql语句硬编码到java代码中，如果sql 语句修改，需要重新编译java代码，不利于系统维护。设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。 3、向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。设想：将sql语句及占位符号和参数全部配置在xml中。 4、从resutSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，，不利于系统维护。设想：将查询的结果集，自动映射成java对象。 3.Mybatis框架的流程图1.SqlMapConfig.xml 是mybatis的全局配置文件，名称不固定的。配置数据源等，配置映射文件（配置sql语句） 2.SqlSessionFactory 会话工厂，根据配置文件来创建工厂，创建SqlSession 3.SqlSession 会话，只一个接口，面向用户（程序员），操作数据库 4.Excutor 执行器，是一个接口（基本执行器，缓存执行器），作用是SqlSession内部通过执行器操作数据库。 5.mapped statemnt 底层封装对象，作用对数据库存储封装，包括sql语句，输入参数，输出结果类型 6.输入参数类型 java简单类型，pojo自定义，hashmap 7.输出结果类型 java简单类型，pojo自定义，hashmap 4.Mybatis的学习重点 Mybatis开发Dao的两种方法 原始的dao开发（程序需要编写dao接口和dao的实现类） (掌握) Mybatis的mapper接口（相当于dao接口）代理的开发（掌握） Mybatis的SqlMapConfig.xml配置（全局的配置文件） Mybatis的核心 Mybatis的输入映射（掌握） Mybatis的输出映射（掌握） Mybatis的动态sql(掌握) 高级映射 高级缓存 spring和mybatis整合 逆向工程","categories":[{"name":"编程","slug":"编程","permalink":"http://blog.cuteximi.com/categories/编程/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://blog.cuteximi.com/tags/mybatis/"}]},{"title":"SpringMVC","slug":"SrpingMVC入门","date":"2017-03-20T11:00:10.000Z","updated":"2017-05-11T12:01:02.000Z","comments":true,"path":"SrpingMVC入门/","link":"","permalink":"http://blog.cuteximi.com/SrpingMVC入门/","excerpt":"学习SpringMVC的过程（一） 什么是SpringMVC 什么是MVC SpringMVC的框架流程图 SpringMVC框架的流程描述 几个重要的组件","text":"学习SpringMVC的过程（一） 什么是SpringMVC 什么是MVC SpringMVC的框架流程图 SpringMVC框架的流程描述 几个重要的组件 1.什么是SpringMVCSpringMVC是Spring的一个模块，SpringMVC和Spring不需要通过中间进行整合（struts2与spring整合需要单独的jar包），springMVC是基于MVC的Web框架。 下图是Spring框架中的SpringMVC 2.什么是MVCMVC是一个设计模式，下图是它在b/s系统下的应用 3.SpringMVC的内部流程 4.SpringMVC框架的流程描述我的天，看这个图是不是不难啊，看着很简单的样子。 这个故事还没有完结 –亚索 一、user向服务器server发起请求，请求到达前端控制器DispatcherServlet 二、前端控制器DispatcherServlet调用处理器映射器HandlerMapping返回该请求的handler 三、处理器映射器HandlerMapping根据url查找请求对应的hander(XML注释、注解) 四、前端控制器DispatcherServlet获取handler之后,调用处理器适配器HandlerAdapter 五、处理器适配器HandlerAdapter来调用Handel处理器，并获去Handel处理器返回的ModelAndView对象 六、处理器适配器将ModelAndView对象返回给前端控制器DispatcherServlet 七、前端控制器DispatcherServlet请求进行视图解析 八、视图解析器View resolver进行解析，很据逻辑视图名，转换成真正的视图（例如：JSP），返回view给前端控制器 DispatcherServlet 九、前端控制器DispatcherServlet请求渲染视图，将ModelAndView对象的内容填充到view中 十、前端控制器DispatcherServlet将响应结果返回给user 5.几个重要的组件从上面的描述中很明显能抽取出几个重要的组件 前端控制器DispatcherServlet 作用：用于接收用户的请求，进行转发，响应，相当于中央处理器，它降低了组件之间的耦合度。相当于中央控制器，掌控着其他个组件的运作。这是不需要程序员自己编写的，框架本身提供了。 处理器映射器HandlerMapping 根据url查找handler，不需要自己编写。 处理器适配器HandlerAdapter 按照特的规则去执行handler 视图解析器View resolver 很据逻辑视图名，转换成真正的视图（例如：JSP）Handel处理器需要程序自己开发，要按照处理器适配器HandlerAdapter特定的规则去编写 view view的一个接口，不同的实现代表不同的view 小结上面的组件只有view和handler处理器是需要自己编写的 学习SpringMVC的过程（二） 项目结构 在web.xml中设置前端控制器 在类路径下的springmvc.xml中配置其他的组件 开发Handler 部署测试一下项目结构在web.xml中设置前端控制器 &lt;servlet> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;init-param> &lt;!-- contextConfigLocation：指定springmvc配置的加载位置 ，如果不指定则默认加载WEB-INF/[DispatcherServlet 的Servlet 名字]-servlet.xml。 --> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc.xml&lt;/param-value> &lt;/init-param> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;url-pattern>*.action&lt;/url-pattern> &lt;!-- url-pattern：*.action的请交给DispatcherServlet处理。 --> &lt;/servlet-mapping> 可以追踪org.springframework.web.servlet.DispatcherServlet的源码，可以看到 user-pattern:解释 第一种：*.action 访问以action结尾，由DispatcherServlet进行解析 第二种：/ 所有访问的地址都由DispatherServlet进行解析，静态文件可以通过配置不使用DispatcherServlet解析，符合Restful风格； 第三种：/* 这是错误的，这样的配置是解析jsp,仍会由DispatherServlet进行解析，不能根据jsp去找到Handler,会报错的！！ 在类路径下的springmvc.xml中配置其他的组件配置处理器适配器&lt;!-- 每个处理器适配器都实现了HandlerAdapter接口 --> &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/> 简单处理器适配器，可以跟踪一下源码： public class SimpleControllerHandlerAdapter implements HandlerAdapter { public boolean supports(Object handler) { return (handler instanceof Controller); } public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return ((Controller) handler).handleRequest(request, response); } public long getLastModified(HttpServletRequest request, Object handler) { if (handler instanceof LastModified) { return ((LastModified) handler).getLastModified(request); } return -1L; } } 可以看到简单处理器支配器实现了Controller接口 配置处理器映射器&lt;!-- 配置处理器映射器 --> &lt;!-- 根据bean的name进行查找Handler 将action的url配置在bean的name中 --> &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/> 配置视图解析器&lt;!-- 配置视图解析器 这个是解析jsp的，默认使用jstl标签，所有classpath路径下要存在jstl的包--> &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/> 配置处理器==这一步需要先自己开发Handler，移至下一步== &lt;!-- 配置处理器 --> &lt;bean name=\"/items.action\" class=\"com.aikuyun.ssm.controller.ItemsController\"/> 解释一下：name属性时自己编写的，处理器映射器隔根据这个name去查找handler 开发Handler==先不关心数据库，只是简单的模拟一下数据== 在com.aikuyun.ssm.controller包中重新建ItemsController.java 代码如下：要实现Controller接口 package com.aikuyun.ssm.controller; import java.util.ArrayList; import java.util.List; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import com.aikuyun.ssm.po.Items; /* * * @ClassName: ItemsController * @Description: TODO(这里用一句话描述这个类的作用) * @author 陶世磊 * @date 2017年3月20日 * */ //实现org.springframework.web.servlet.mvc.Controller接口，按照特定的规范 public class ItemsController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { // 商品列表 List&lt;Items> itemsList = new ArrayList&lt;Items>(); Items items_1 = new Items(); items_1.setName(\"联想笔记本\"); items_1.setPrice(6000f); items_1.setDetail(\"ThinkPad T430 联想笔记本电脑！\"); Items items_2 = new Items(); items_2.setName(\"苹果手机\"); items_2.setPrice(5000f); items_2.setDetail(\"iphone6苹果手机！\"); itemsList.add(items_1); itemsList.add(items_2); //创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); // 填充数据 modelAndView.addObject(\"itemsList\", itemsList); // 填充视图 modelAndView.setViewName(\"/WEB-INF/items/itemsList.jsp\"); //返回ModelAndView return modelAndView; } } 开发Handler之后要在配置文件中配置该类，==返回看上一步==； 部署测试一下打开服务器之后，在浏览器里访问：http://localhost:8080/项目名/items.action 查看测试结果，OK! 学习SpringMVC的过程（三） 非注解的处理器适配器和处理器映射器 DispatcherSerlvet.properties 注解的处理器适配器和处理器映射器 非注解的处理器适配器和处理器映射器非注解的处理器映射器非注解的处理器映射器主要学习两个 ```org.springframework.web.servlet.handler.SimpleUrlHandlerMapping```简单url映射 在配置文件中进行配置如下： ```xml itemsController 分别看一下源码：理解一下原理 ```java public class BeanNameUrlHandlerMapping extends AbstractDetectingUrlHandlerMapping { /** * Checks name and aliases of the given bean for URLs, starting with \"/\". */ @Override //很据benaname查找，要在对应的handler的bean里面加上name属性 protected String[] determineUrlsForHandler(String beanName) { List urls = new ArrayList(); if (beanName.startsWith(\"/\")) { urls.add(beanName); } String[] aliases = getApplicationContext().getAliases(beanName); for (String alias : aliases) { if (alias.startsWith(\"/\")) { urls.add(alias); } } return StringUtils.toStringArray(urls); } } ==很据benaname查找，要在对应的handler的bean里面加上name属性== ```java public class SimpleUrlHandlerMapping extends AbstractUrlHandlerMapping { private final Map urlMap = new HashMap(); /** * Map URL paths to handler bean names. * This is the typical way of configuring this HandlerMapping. * Supports direct URL matches and Ant-style pattern matches. For syntax * details, see the {@link org.springframework.util.AntPathMatcher} javadoc. * @param mappings properties with URLs as keys and bean names as values * @see #setUrlMap */ public void setMappings(Properties mappings) { CollectionUtils.mergePropertiesIntoMap(mappings, this.urlMap); } /** * Set a Map with URL paths as keys and handler beans (or handler bean names) * as values. Convenient for population with bean references. * Supports direct URL matches and Ant-style pattern matches. For syntax * details, see the {@link org.springframework.util.AntPathMatcher} javadoc. * @param urlMap map with URLs as keys and beans as values * @see #setMappings */ public void setUrlMap(Map urlMap) { this.urlMap.putAll(urlMap); } /** * Allow Map access to the URL path mappings, with the option to add or * override specific entries. * Useful for specifying entries directly, for example via \"urlMap[myKey]\". * This is particularly useful for adding or overriding entries in child * bean definitions. */ public Map getUrlMap() { return this.urlMap; } /** * Calls the {@link #registerHandlers} method in addition to the * superclass's initialization. */ @Override public void initApplicationContext() throws BeansException { super.initApplicationContext(); registerHandlers(this.urlMap); } /** * Register all handlers specified in the URL map for the corresponding paths. * @param urlMap Map with URL paths as keys and handler beans or bean names as values * @throws BeansException if a handler couldn't be registered * @throws IllegalStateException if there is a conflicting handler registered */ protected void registerHandlers(Map urlMap) throws BeansException { if (urlMap.isEmpty()) { logger.warn(\"Neither 'urlMap' nor 'mappings' set on SimpleUrlHandlerMapping\"); } else { for (Map.Entry entry : urlMap.entrySet()) { String url = entry.getKey(); Object handler = entry.getValue(); // Prepend with slash if not already present. if (!url.startsWith(\"/\")) { url = \"/\" + url; } // Remove whitespace from handler bean name. if (handler instanceof String) { handler = ((String) handler).trim(); } registerHandler(url, handler); } } } } ==需要在bean里面输入map集合的参数key指定url,value指定要映射的handler== 非注解的处理器适配器学两个非注解的适配器 一个是：org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter开发的处理器必须实现Controller接口 另一个是：org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter开发的处理必须实现HttpRequestHandler接口 DispatcherSerlvet.properties前端控制器器从上面的属性文件中加载配置其他组件的加载类型，如果用户不自定义编写加载处理，用使用这个属性文件的的配置组件； 注解的处理器适配器和处理器映射器注意： 在spring3.1之前使用 org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping注解映射器。 在spring3.1之后使用 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping注解映射器。 在spring3.1之前使用 org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter注解适配器。 在spring3.1之后使用 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter注解适配器。 配置注解映射器和适配器在springmvc.xml中，加入： &lt;!-- 配置注解映射器和适配器 --> &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\">&lt;/bean> &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">&lt;/bean> ==还有一种配置方式：（实际开发用这种）== &lt;!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的 RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --> &lt;mvc:annotation-driven>&lt;/mvc:annotation-driven> &lt;!-- 配置处理器 --> 开发Handler代码部分： package com.aikuyun.ssm.controller; import java.util.ArrayList; import java.util.List; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; import com.aikuyun.ssm.po.Items; /* * * @ClassName: ItemsController * @Description: TODO(注解的适配器和映射器) * @author 陶世磊 * @date 2017年3月22日 * */ //使用Controller表示，它是一个控制器 @Controller public class ItemsController3{ //注解，对方法和url进行映射，一个方法对应一个url(可以写多个方法) @RequestMapping(\"/queryItems\") public ModelAndView queryItems() throws Exception { // 商品列表 List&lt;Items> itemsList = new ArrayList&lt;Items>(); Items items_1 = new Items(); items_1.setName(\"联想笔记本\"); items_1.setPrice(6000f); items_1.setDetail(\"ThinkPad T430 联想笔记本电脑！\"); Items items_2 = new Items(); items_2.setName(\"苹果手机\"); items_2.setPrice(5000f); items_2.setDetail(\"iphone6苹果手机！\"); itemsList.add(items_1); itemsList.add(items_2); // ModelAndView modelAndView = new ModelAndView(); // 填充数据 modelAndView.addObject(\"itemsList\", itemsList); // 填充视图 modelAndView.setViewName(\"/WEB-INF/items/itemsList.jsp\"); return modelAndView; } } 在Spring容器中加载Handler&lt;!-- 对于注解的Handler可以单个配置 实际开发中建议使用组件扫描 --> &lt;!-- &lt;bean class=\"cn.itcast.ssm.controller.ItemsController3\" /> --> &lt;!-- 可以扫描controller、service、... 这里让扫描controller，指定controller的包 --> &lt;context:component-scan base-package=\"cn.itcast.ssm.controller\">&lt;/context:component-scan> 部署调试访问：http://localhost:8080/SpringMVC20170320/queryItems.action 这里出现了一个困扰我很久 的问题，查了很多资料之后恍然大悟。 学习SpringMVC的过程（四） springmvc和mybatis整合的思路 准备环境 开始搭建 加载spring容器 springmvc和mybatis整合的思路 准备环境 jdk eclipse mysql数据库 mybatis的jar包以及它的依赖包 spring-mybatis的整合包 spring的jar包 springmvc的jar包 jstl的jar包 数据库驱动包 数据源的jar包 单元测试的junit包 log4j的日志包 项目的目录结构如下： 开始搭建整合dao1.mybatis的配置文件sqlMapConfig.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;!-- 定义别名 --> &lt;typeAliases> &lt;!-- 批量定义别名 指定包名，mybatis会自动扫描该包下的po类，别名就是类型（首字母可以大写或者小写） --> &lt;package name=\"com.ssm.po\"/> &lt;/typeAliases> &lt;!-- 加载配置文件 --> &lt;!-- &lt;mappers> 批量加载mapper 指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 中 上边规范的前提是：使用的是mapper代理方法 &lt;package name=\"com.aikuyun.ssm.mapper\"/> &lt;/mappers> --> &lt;/configuration> 2.applicationContext-dao.xml配置数据源，配置SqlSessionFactory，扫描mapper接口 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd\"> &lt;!-- 加载属性文件，该属性文件的命名规则要有一定的特殊性 --> &lt;context:property-placeholder location=\"classpath:db.properties\"/> &lt;!-- 配置数据源 --> &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"> &lt;property name=\"driverClassName\" value=\"${jdbc.driver}\" /> &lt;property name=\"url\" value=\"${jdbc.url}\" /> &lt;property name=\"username\" value=\"${jdbc.username}\" /> &lt;property name=\"password\" value=\"${jdbc.password}\" /> &lt;property name=\"maxActive\" value=\"30\" /> &lt;property name=\"maxIdle\" value=\"5\" /> &lt;/bean> &lt;!-- 配置SqlSessionFactory --> &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"> &lt;property name=\"configLocation\" value=\"classpath:mybatis/sqlMapConfig.xml\">&lt;/property> &lt;property name=\"dataSource\" ref=\"dataSource\">&lt;/property> &lt;/bean> &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"> &lt;property name=\"basePackage\" value=\"com.ssm.mapper\">&lt;/property> &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\">&lt;/property> &lt;/bean> &lt;/beans> 整合service1.定义一个service接口 和mapper接口里面的方法一样 2.在applicationContext-service.xml中配置service &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-3.2.xsd\"> &lt;bean id=\"itemsService\" class=\"com.ssm.service.imp.ItemsServiceImp\">&lt;/bean> &lt;/beans> 3.在applicationContext-transaction.xml中配置事务 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd\"> &lt;!-- 事务管理器 对mybatis操作数据库事务控制，spring使用jdbc的事务控制类 --> &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"> &lt;!-- 数据源 dataSource在applicationContext-dao.xml中配置了 --> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;/bean> &lt;!-- 通知 --> &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"> &lt;tx:attributes> &lt;!-- 传播行为 --> &lt;tx:method name=\"save*\" propagation=\"REQUIRED\"/> &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/> &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\"/> &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/> &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/> &lt;tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\"/> &lt;tx:method name=\"select*\" propagation=\"SUPPORTS\" read-only=\"true\"/> &lt;/tx:attributes> &lt;/tx:advice> &lt;!-- aop --> &lt;aop:config> &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.ssm.service.impl.*.*(..))\"/> &lt;/aop:config> &lt;/beans> 整合springmvc1.springmvc.xml文件里配置前端控制器，适配器，映射器，视图解析器，Handler &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd\"> &lt;!-- 配置注解的适配器 和注解的映射器 --> &lt;mvc:annotation-driven>&lt;/mvc:annotation-driven> &lt;!--配置视图解析器 --> &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;property name=\"prefix\" value=\"/WEB-INF/\">&lt;/property> &lt;property name=\"suffix\" value=\".jsp\">&lt;/property> &lt;/bean> &lt;!--扫描handler --> &lt;context:component-scan base-package=\"com.ssm.controller\"> &lt;/context:component-scan> &lt;/beans> 2.配置前端控制器—在web.xml中加入： servlet> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:spring/springmvc.xml&lt;/param-value> &lt;/init-param> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>springmvc&lt;/servlet-name> &lt;url-pattern>*.action&lt;/url-pattern> &lt;/servlet-mapping> 3.编写Handler package com.ssm.controller; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; import com.ssm.mapper.ItemsMapper; import com.ssm.po.ItemsCustom; @Controller public class ItemsController { @Autowired private ItemsMapper itemsMapper; @RequestMapping(\"/queryItems\") public ModelAndView queryItems() throws Exception{ List&lt;ItemsCustom> itemsList = itemsMapper.findItems(null); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"itemsList\",itemsList); modelAndView.setViewName(\"items/itemsList\"); return modelAndView; } } 4.编写jsp &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%> &lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%> &lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\"%> &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> &lt;html> &lt;head> &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"> &lt;title>查询商品列表&lt;/title> &lt;/head> &lt;body> &lt;form action=\"${pageContext.request.contextPath }/item/queryItem.action\" method=\"post\"> 查询条件： &lt;table width=\"100%\" border=1> &lt;tr> &lt;td>&lt;input type=\"submit\" value=\"查询\" />&lt;/td> &lt;/tr> &lt;/table> 商品列表： &lt;table width=\"100%\" border=1> &lt;tr> &lt;td>商品名称&lt;/td> &lt;td>商品价格&lt;/td> &lt;td>生产日期&lt;/td> &lt;td>商品描述&lt;/td> &lt;td>操作&lt;/td> &lt;/tr> &lt;c:forEach items=\"${itemsList }\" var=\"item\"> &lt;tr> &lt;td>${item.name }&lt;/td> &lt;td>${item.price }&lt;/td> &lt;td>&lt;fmt:formatDate value=\"${item.createtime}\" pattern=\"yyyy-MM-dd HH:mm:ss\" />&lt;/td> &lt;td>${item.detail }&lt;/td> &lt;td>&lt;a href=\"${pageContext.request.contextPath }/item/editItem.action?id=${item.id}\">修改&lt;/a>&lt;/td> &lt;/tr> &lt;/c:forEach> &lt;/table> &lt;/form> &lt;/body> &lt;/html> 加载spring容器在web.xml中加入： &lt;!-- 加载spring容器 --> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>/WEB-INF/classes/spring/applicationContext-dao.xml, /WEB-INF/classes/spring/applicationContext-service.xml,/WEB-INF/classes/spring/applicationContext-tansaction.xml&lt;/param-value> &lt;/context-param> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener> 完成上面所有工作之后的项目结构：","categories":[{"name":"编程","slug":"编程","permalink":"http://blog.cuteximi.com/categories/编程/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://blog.cuteximi.com/tags/SpringMVC/"}]},{"title":"爱久一点","slug":"爱久一点","date":"2017-03-19T13:09:02.000Z","updated":"2017-03-28T14:05:56.000Z","comments":true,"path":"爱久一点/","link":"","permalink":"http://blog.cuteximi.com/爱久一点/","excerpt":"爱少一点，但请爱久一点。 -taoximi 如果一个人对另一个的热情有个固定的量，我希望你不要一次性塞给我，因为我不想承受热烈温度冷却后的巨大失落。 有的人刚和你在一起的时候，会让你觉得，“怎么会有对我这么好的人啊。” 他会大半夜给你买想吃的夜宵；给你精心准备礼物和惊喜； 你说生病了他会第一时间出现在你楼下带你去医院，而不是让你多喝热水；","text":"爱少一点，但请爱久一点。 -taoximi 如果一个人对另一个的热情有个固定的量，我希望你不要一次性塞给我，因为我不想承受热烈温度冷却后的巨大失落。 有的人刚和你在一起的时候，会让你觉得，“怎么会有对我这么好的人啊。” 他会大半夜给你买想吃的夜宵；给你精心准备礼物和惊喜； 你说生病了他会第一时间出现在你楼下带你去医院，而不是让你多喝热水；他带你去听你爱的歌手的演唱会，陪你去你一直想去的地方旅行。 你每天都被包裹在巨大的幸福里。只要看到手机推送是他发来的微信就不由自主浮上满眼睛的笑意。 以前不懂朋友圈各种秀恩爱行为的你，也忍不住地发状态喂别人狗粮。 但慢慢的，你发现他回复地越来越慢了，聊天时候打的字也越来越少。工作没变，却比以前忙很多，不再经常陪你。他开始嫌你黏人，你的不安全感在他眼里是疑神疑鬼和无理取闹。 甚至吵架都懒得认真吵，只留下一句“你这么想我也没办法”。他没离开，但他用冷暴力让你不得不离开了。 如果你有一天会变成这样，那么我希望你一开始就不要对我这么好。 让人最痛苦的不是没吃过好吃的东西，而是吃到了世界上最好吃的东西，却再也尝不到了。 曾经沧海难为水，就是这个道理吧。 “爱我少一点，爱我久一点” 为什么有些人的爱这么快就用光了？ 因为那不是爱啊。乍见之欢或许只是新鲜感，久处不厌才是爱的真正样子。我不要昙花一现的轰轰烈烈，我要真真切切的日久天长。 如果热情是电的话，新鲜感只是一块电池，而爱是源源不断供电的发电机。 我看过头发花白的老夫妇捧着爆米花进电影院影厅看电影； 看过一个老爷爷买了两个新品甜筒颤巍巍地拿给老伴吃； 还看过游乐场带着米妮大耳朵发箍的老奶奶被身边的老爷爷夸好看。 为了满足新鲜感，有的人总要跟不同的人做同样的事，有的人却一辈子跟同样的人去做不同的事。这些甜蜜几十年不变的老爷爷老奶奶们都是后者，所以他们拥有相濡以沫的长久。 从你的风华正茂，到你的垂垂老矣，岁月让容颜变迁，但我对你的热情从未有丝毫减少。爱你很久很久，久到一生只够爱一个人。 两个人之间不可能永远热情似火，当激情褪去后才能靠近真实的对方。 不爱你的人就只剩下倦怠，简单地说就是腻了。他开始计较你的毛病，眼里只看到你的缺点，直到你在他眼里一无是处，他就果断离开。 爱你的人早已把爱你当成一种习惯，像每天吃饭喝水一样，给你简单平实的关心、照顾和陪伴。 在他眼里，你化好妆美艳动人的样子可爱，在家头发凌乱素面朝天的样子也可爱。你的优点在他眼里闪闪发光，你的小脾气和缺点他会包容。 爱你这件事，完全不需要刻意地去坚持，就像呼吸一样自然地烙印在了往后的生活里。是冬天热气腾腾的早饭，是夜晚睡着后无意识的怀抱，是吵完架出门买菜买了你爱吃的土豆牛腩。 愿你欣喜的不再是一时的热烈，而是温暖如初的细水长流。 愿你拥有的爱，是平淡日子里最长情的存在。","categories":[{"name":"生活","slug":"生活","permalink":"http://blog.cuteximi.com/categories/生活/"}],"tags":[{"name":"love","slug":"love","permalink":"http://blog.cuteximi.com/tags/love/"}]},{"title":"迈出第一步","slug":"hello-world","date":"2017-03-18T14:47:46.000Z","updated":"2017-07-28T00:52:54.000Z","comments":true,"path":"hello-world/","link":"","permalink":"http://blog.cuteximi.com/hello-world/","excerpt":"","text":"Welcome to 爱酷云! This is my first blog. 2017.3.18关于建立博客的初衷学习的过程是一个自我能力提升的一个重要阶段，加油！你是最棒的","categories":[],"tags":[]}]}